{"_id":"post-c32ee546-b675-4375-bdeb-b7cf4ca86330","_type":"post","title":"Rebuilding the Replit Filetree for Superior Performance and Accessibility","slug":{"_type":"slug","current":"filetree-updates"},"body":[{"_key":"0e29c83ddd74","children":[{"_type":"span","_key":"0e29c83ddd740","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"5901edf128c6","children":[{"_type":"span","marks":["em"],"text":"We recently rebuilt the Replit filetree with a focus on performance and accessibility. The result? Quicker interactions when exploring large projects and a more accessible experience with improvements like keyboard navigation. Here’s a summary of how the new filetree works.","_key":"5901edf128c60"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"1ba6b6523b7c","children":[{"_type":"span","marks":[],"text":"In the early days of Replit, it served as a simple but powerful editor and console. As our user base grew and their projects became more complex, we understood the need for a filesystem and, consequently, a filetree.","_key":"1ba6b6523b7c0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"92fc9de0bfb2","children":[{"_type":"span","marks":[],"text":"This filetree worked for small projects but started to have some performance issues as projects grew in size. This was particularly noticeable once we started using ","_key":"92fc9de0bfb20"},{"_type":"span","marks":["ab4f3a2856f8"],"text":"Replit to build Replit","_key":"92fc9de0bfb21"},{"_type":"span","marks":[],"text":" – our web repo had around 8000 files. We decided to revamp the filetree, and today, we’re excited to share the improvements we’ve made, focusing on performance and accessibility.","_key":"92fc9de0bfb22"}],"markDefs":[{"_key":"ab4f3a2856f8","_type":"link","href":"https://www.youtube.com/watch?v=7TCqGslll-4&t=1835"}],"_type":"block","style":"normal"},{"_key":"cd5bf0671aff","children":[{"_type":"span","marks":[],"text":"Reimagining the filetree: prioritizing performance","_key":"cd5bf0671aff0"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"5809f714ddf3","children":[{"_type":"span","marks":[],"text":"Virtualization","_key":"5809f714ddf30"}],"markDefs":[],"_type":"block","style":"h3"},{"_key":"104ca2cf6a98","children":[{"_type":"span","marks":[],"text":"The most significant source of performance issues for large filetrees was rendering all the rows, even those invisible to the user. Think of it like trying to read a hefty novel all at once - it's not efficient or practical. To solve this, we turned to ","_key":"104ca2cf6a980"},{"_type":"span","marks":["0d3c370db72c"],"text":"virtualization","_key":"104ca2cf6a981"},{"_type":"span","marks":[],"text":". In essence, we now only render what's visible, or about to be visible while scrolling, making the process significantly faster and smoother.","_key":"104ca2cf6a982"}],"markDefs":[{"_key":"0d3c370db72c","_type":"link","href":"https://www.patterns.dev/posts/virtual-lists"}],"_type":"block","style":"normal"},{"_key":"c2a16e4eafb4","children":[{"_type":"span","marks":[],"text":"Before this change, if you were to expand a directory with many files the UI could become unresponsive while all the rows are being rendered. Here’s a snapshot of the click handler executing when expanding a directory with 500 files.","_key":"c2a16e4eafb40"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"112b8750d612","children":[{"_type":"span","marks":[],"text":"The click handler on the old filetree took 344ms. ","_key":"112b8750d6120"},{"_type":"span","marks":["6ff2f75a0a1a"],"text":"Speed matters","_key":"112b8750d6121"},{"_type":"span","marks":[],"text":", so this is not good!","_key":"112b8750d6122"}],"markDefs":[{"_key":"6ff2f75a0a1a","_type":"link","href":"https://services.google.com/fh/files/blogs/google_delayexp.pdf"}],"_type":"block","style":"normal"},{"_key":"dafe1d517be6","children":[{"_type":"span","_key":"dafe1d517be60","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"927be648d583","children":[{"_type":"span","marks":[],"text":"The new one only took 16ms.","_key":"927be648d5830"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"36caa590795e","children":[{"_type":"span","marks":[],"text":"Virtualizing presented some challenges. A filetree is a \"tree,\" but to virtualize it we needed to render it as a flat list. To accomplish this, we took the data stored as a tree structure and flattened it into a list based on the loaded files and the expanded state of directories.","_key":"36caa590795e0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"0cd06119aaac","children":[{"_type":"span","marks":[],"text":"Another challenge of virtualization is that the HTML elements don't represent the tree structure. In the old filetree, we could rely on the parent element for each directory and use that to render a drop preview and gutter markers. With the virtualized approach, we needed to calculate the geometry of the views based on the tree data (rather than the tree view). Because of this change, we could also morph the drop preview size and position, since it’s a single element moving around instead of multiple elements inside each drop target. This makes the interaction feel fluid, helping you track where a file will be dropped.","_key":"0cd06119aaac0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"149370c1dd7a","children":[{"_type":"span","_key":"149370c1dd7a0","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"053f91f57917","children":[{"_type":"span","marks":[],"text":"Local caching","_key":"053f91f579170"}],"markDefs":[],"_type":"block","style":"h3"},{"_key":"03262e566795","children":[{"_type":"span","marks":[],"text":"Another way we boosted performance was by using local caching. This ensures recently viewed filetrees are readily available for immediate rendering in a read-only view. Once you're connected to the container, everything becomes editable, and any potential remote changes are synced. This allows you to see the files in your Repls faster, even when your network speed is slow.","_key":"03262e5667950"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"49ce29241948","children":[{"_type":"span","_key":"49ce292419480","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"dc2d4e56928f","children":[{"_type":"span","marks":[],"text":"Enhanced accessibility","_key":"dc2d4e56928f0"}],"markDefs":[],"_type":"block","style":"h3"},{"_key":"fb27e2d44ab8","children":[{"_type":"span","marks":[],"text":"Beyond performance, we also wanted to make our filetree more accessible. The old filetree had its limitations, especially in terms of keyboard accessibility. Making the new filetree keyboard accessible was mostly straightforward since we can easily map between the tree data structure and the derived flat list to move the focus around and expand/collapse directories. The flat list needed for virtualization did present some accessibility challenges. For example, we needed to add ","_key":"fb27e2d44ab80"},{"_type":"span","marks":["e9831c21a9f1"],"text":"aria-level","_key":"fb27e2d44ab81"},{"_type":"span","marks":[],"text":" to define the hierarchical level of a file within the tree since the browser can’t infer it from that structure of the elements. This attribute exposes hierarchy to assistive technologies so it can be communicated to the users. Overall, these accessibility updates will allow you to conveniently move focus around and expand/collapse directories.","_key":"fb27e2d44ab82"}],"markDefs":[{"_key":"e9831c21a9f1","_type":"link","href":"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-level"}],"_type":"block","style":"normal"},{"_key":"15062673bc93","children":[{"_type":"span","_key":"15062673bc930","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"3bb71cfd6247","children":[{"_type":"span","marks":[],"text":"Easy reusability","_key":"3bb71cfd62470"}],"markDefs":[],"_type":"block","style":"h3"},{"_key":"30f7d041db69","children":[{"_type":"span","marks":[],"text":"While performance and accessibility were the primary motivations for an improved filetree, we also wanted to make sure it was an abstraction that was easy to reuse. For example, the same filetree in the sidebar is used in the file path breadcrumb menu, so you can drag/drop and create files directly from the menu. This is useful since you often create new files relative to the directory of the file you are editing for styles, tests, or refactoring.","_key":"30f7d041db690"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"775b9cc0f3c7","children":[{"_type":"span","marks":[],"text":"Speed is a feature","_key":"775b9cc0f3c70"}],"markDefs":[],"_type":"block","style":"h3"},{"_key":"790ded64eebe","children":[{"_type":"span","marks":[],"text":"Just like a conversation between humans, interactions with computers need to be fast to be effective. Nobody likes ","_key":"790ded64eebe0"},{"_type":"span","marks":["5131ddc7caf7"],"text":"slow software","_key":"790ded64eebe1"},{"_type":"span","marks":[],"text":", and we understand that. This new filetree is part of our ongoing efforts to make Replit quicker, more efficient, and user-friendly. We invite you to try out the new features, see the difference in performance and accessibility, and let us know your thoughts!","_key":"790ded64eebe2"}],"markDefs":[{"_key":"5131ddc7caf7","_type":"link","href":"https://www.inkandswitch.com/slow-software/"}],"_type":"block","style":"normal"}],"publishedAt":"2023-08-01T00:00:00.000Z"}