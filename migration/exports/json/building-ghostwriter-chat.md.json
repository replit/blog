{"_id":"post-51f3cd5c-8879-46a7-810d-6be8075ba4fa","_type":"post","title":"Building Ghostwriter Chat","slug":{"_type":"slug","current":"building-ghostwriter-chat"},"body":[{"_key":"54dfc6574fef","children":[{"_type":"span","_key":"54dfc6574fef0","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"1baee675eb86","children":[{"_type":"span","marks":[],"text":"Why did we build it?","_key":"1baee675eb860"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"27f4d2284fec","children":[{"_type":"span","marks":[],"text":"At Replit, we want to give people the most powerful programming environment, and what better way is there than giving people access to a pair programmer directly in their IDE? Enter Ghostwriter Chat.","_key":"27f4d2284fec0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"73cba00b3861","children":[{"_type":"span","marks":[],"text":"Gone are the days where you had to search Stack Overflow for an obscure error message or visit the docs of your favorite package for the millionth time because you forgot what that one argument was called. Interacting with Ghostwriter should be as easy as interacting with a team member, and it is. Since Ghostwriter Chat can have access to your repl file and context, Ghostwriter can help answer questions about your program without copying and pasting entire code blocks.","_key":"73cba00b38610"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"341912e8af02","children":[{"_type":"span","marks":[],"text":"We started working on Ghostwriter Chat during our Hackweek in January, and we wanted to be the first to market with an LLM chat application native to your editor. From start to finish, we shipped the product in ~6-8 weeks","_key":"341912e8af020"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"73045d08a71f","children":[{"_type":"span","_key":"73045d08a71f0","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"9cf8d8f65a92","children":[{"_type":"span","marks":[],"text":"Large Language Models","_key":"9cf8d8f65a920"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"2eade2ab75af","children":[{"_type":"span","marks":["bd4787cfec2a"],"text":"Large language models","_key":"2eade2ab75af0"},{"_type":"span","marks":[],"text":" (LLMs) are the underlying technology powering Ghostwriter Chat. The recent advancements in the field make these language models very good at answering programming questions.","_key":"2eade2ab75af1"}],"markDefs":[{"_key":"bd4787cfec2a","_type":"link","href":"https://blogs.nvidia.com/blog/2023/01/26/what-are-large-language-models-used-for/"}],"_type":"block","style":"normal"},{"_key":"6ff924feba03","children":[{"_type":"span","marks":[],"text":"A typical chat request goes through the following steps:","_key":"6ff924feba030"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"390aa9841e87","children":[{"_type":"span","_key":"390aa9841e870","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"8c8d0a8876fe","children":[{"_type":"span","marks":[],"text":"The LLM is the contributor to the largest amount of latency in this process, so streaming the results back instead of waiting for the entire completion is important. If we do not stream, a user will have to wait multiple seconds for the language model to generate all tokens. Streaming gives us the ability to have sub 500 milliseconds from the time a request is sent, to when the user starts seeing a response displayed.","_key":"8c8d0a8876fe0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"09abc088013f","children":[{"_type":"span","marks":[],"text":"Generic Prompt Construction","_key":"09abc088013f0"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"3cae263a3c48","children":[{"_type":"span","marks":[],"text":"When working with LLMs, you need to invest a lot of thought into how you construct the prompt that you feed in. A carefully constructed prompt with sufficient context, can yield a very detailed response while a simple, basic prompt can yield something that is not very helpful.","_key":"3cae263a3c480"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"659961a29c23","children":[{"_type":"span","marks":[],"text":"For Ghostwriter to be able to help you answer your questions, it needs to have knowledge of the ever changing environment of your repl and your chat history. To succeed, we needed a way to take varying information from different sources, choose what to include and exclude, and convert it to any number of prompt formats to support any number of models and APIs.","_key":"659961a29c230"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"07314aaf433c","children":[{"_type":"span","_key":"07314aaf433c0","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"fdc4ac18ec17","children":[{"_type":"span","marks":[],"text":"Ghostwriter Debugger","_key":"fdc4ac18ec170"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"387199edb508","children":[{"_type":"span","marks":[],"text":"For Ghostwriter Debugger to work, we also need to support the many different ways programs display and throw errors. For example, a running web server can throw errors without pausing execution and continue to output logs, but a script is going to immediately stop with the last output being an error message.","_key":"387199edb5080"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"5c62d70164b6","children":[{"_type":"span","_key":"5c62d70164b60","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"ebd834475fcc","children":[{"_type":"span","marks":[],"text":"Getting Around Token Limits","_key":"ebd834475fcc0"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"72bdfdd86526","children":[{"_type":"span","marks":[],"text":"Unfortunately, language models have a token limit on the input and output tokens. This makes it impossible for us to include all of your repl context, additional external context, and your entire chat history. To get around this, we use some heuristics we feel is a good balance to allow chat to have access to what is most important.","_key":"72bdfdd865260"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"c67dbb27632b","children":[{"_type":"span","marks":[],"text":"Limit the chat history we send to the model","_key":"c67dbb27632b0"}],"markDefs":[],"_type":"block","style":"h4"},{"_key":"d41a2398da36","children":[{"_type":"span","marks":[],"text":"Assuming that the most recent messages are the most important during a conversation, removing old messages is a good way to keep in these context limits.","_key":"d41a2398da360"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"925dd640016d","children":[{"_type":"span","marks":[],"text":"Set a cap on how large a message can be","_key":"925dd640016d0"}],"markDefs":[],"_type":"block","style":"h4"},{"_key":"7f35256a613f","children":[{"_type":"span","marks":[],"text":"A message to Ghostwriter counts as part of the prompt and the total limit, so we set a cap at ","_key":"7f35256a613f0"},{"_type":"span","marks":["code"],"text":"500","_key":"7f35256a613f1"},{"_type":"span","marks":[],"text":" characters to allow more room for other parts of the prompt (chat history, larger responses, file context). If most users want to reference code they have written in a message and we are including file context already, you can get better results by asking Ghostwriter about the code itself instead of copying and pasting in each message.","_key":"7f35256a613f2"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"06f0f1f3ba2e","children":[{"_type":"span","marks":[],"text":"Be smart about what is good context and what is bad context","_key":"06f0f1f3ba2e0"}],"markDefs":[],"_type":"block","style":"h4"},{"_key":"61101786a2b0","children":[{"_type":"span","marks":[],"text":"For example, a small Repl might only have a hundred or so lines of code and two files. That is very easy to keep the full context of the repl when interacting with Ghostwriter. But what about larger and more complex Repls? It's impossible to send the entire project to a language model, let alone the entire project and your chat history.","_key":"61101786a2b00"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"08c5b487fdef","children":[{"_type":"span","marks":[],"text":"Some files are less relevant than others. A python project might have a directory called ","_key":"08c5b487fdef0"},{"_type":"span","marks":["code"],"text":".venv/","_key":"08c5b487fdef1"},{"_type":"span","marks":[],"text":", some linter files, some ","_key":"08c5b487fdef2"},{"_type":"span","marks":["code"],"text":"pytest","_key":"08c5b487fdef3"},{"_type":"span","marks":[],"text":" configurations, a ","_key":"08c5b487fdef4"},{"_type":"span","marks":["code"],"text":".gitignore","_key":"08c5b487fdef5"},{"_type":"span","marks":[],"text":" file, and a bunch of ","_key":"08c5b487fdef6"},{"_type":"span","marks":["code"],"text":"yaml","_key":"08c5b487fdef7"},{"_type":"span","marks":[],"text":" CI build files. Are these really going to help make Ghostwriter give users better programming advice? Most likely not. The most relevant files would be things like ","_key":"08c5b487fdef8"},{"_type":"span","marks":["code"],"text":"main.py","_key":"08c5b487fdef9"},{"_type":"span","marks":[],"text":" and other source code.","_key":"08c5b487fdef10"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"33ac50db7182","children":[{"_type":"span","marks":[],"text":"When programming, an example workflow is to think about what you want to do, write some code, forget the best way to do something, look it up, and repeat. This isnt always the case, but if you are focusing programming and you are stuck, it's almost on the immediate task at hand. We can take advantage of this common flow, by assuming that the most important files for Ghostwriter to know about are the files you are currently working on and have recently worked on. Doing so gives Ghostwriter the most context on the task you are doing at hand and enables it to truly be your pair programmer.","_key":"33ac50db71820"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"a60d0d11143a","children":[{"_type":"span","marks":[],"text":"The Future","_key":"a60d0d11143a0"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"6eb760c1f2a7","children":[{"_type":"span","marks":[],"text":"Ghostwriter Chat will only get more and more powerful as AI and LLMs become stronger. Token limits will get larger, inference speeds will get faster, which means future versions of Ghostwriter, and other LLM based applications, will only get smarter, better, and faster.","_key":"6eb760c1f2a70"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"f55cf44fff72","children":[{"_type":"span","marks":[],"text":"These trends will allow us to unlock more seamless interaction with our IDE, leverage more file context, and allow Ghostwriter to do more complex actions. Ghostwriter will continue to grow and innovate.","_key":"f55cf44fff720"}],"markDefs":[],"_type":"block","style":"normal"}]}