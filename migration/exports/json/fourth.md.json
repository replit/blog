{"_id":"post-d1dd5dc6-6533-43a3-bcb9-1e9c827ee167","_type":"post","title":"The Fourth Age Of Programming","slug":{"_type":"slug","current":"fourth"},"body":[{"_key":"ceaed5be6921","children":[{"_type":"span","marks":[],"text":"The ","_key":"ceaed5be69210"},{"_type":"span","marks":["strong"],"text":"technological singularity","_key":"ceaed5be69211"},{"_type":"span","marks":[],"text":"—or simply the singularity—is a hypothetical future point in time at which technological growth becomes uncontrollable and irreversible, resulting in unforeseeable changes to human civilization. According to the most popular version of the singularity hypothesis, I.J. Good's intelligence explosion model, an upgradable intelligent agent will eventually enter a \"runaway reaction\" of self-improvement cycles, each new and more intelligent generation appearing more and more rapidly, causing an \"explosion\" in intelligence and resulting in a powerful superintelligence that qualitatively far surpasses all human intelligence. — Wikipedia","_key":"ceaed5be69212"}],"markDefs":[],"_type":"block","style":"blockquote"},{"_key":"95884b56f7e0","children":[{"_type":"span","marks":[],"text":"In normieland, where I still spend plenty of time both online and IRL, software’s newfound ability to write, draw, and speak like we humans is often taken as evidence that the machines are about to remake our entire society (again) and totally change the nature and value of labor (again). I don’t think the normies are wrong about this, but as flashy as ","_key":"95884b56f7e00"},{"_type":"span","marks":["8f97bcceefc0"],"text":"Stable Diffusion","_key":"95884b56f7e01"},{"_type":"span","marks":[],"text":" and ","_key":"95884b56f7e02"},{"_type":"span","marks":["dcf4a41939b1"],"text":"ChatGPT","_key":"95884b56f7e03"},{"_type":"span","marks":[],"text":" are, old heads know that the Robot Apocalypse has exactly ","_key":"95884b56f7e04"},{"_type":"span","marks":["c02c22ca07d0"],"text":"one and only one horseman","_key":"95884b56f7e05"},{"_type":"span","marks":[],"text":": ","_key":"95884b56f7e06"},{"_type":"span","marks":["strong"],"text":"computer programs that can write computer programs","_key":"95884b56f7e07"},{"_type":"span","marks":[],"text":".","_key":"95884b56f7e08"}],"markDefs":[{"_key":"8f97bcceefc0","_type":"link","href":"https://www.jonstokes.com/p/getting-started-with-stable-diffusion"},{"_key":"dcf4a41939b1","_type":"link","href":"https://openai.com/blog/chatgpt/"},{"_key":"c02c22ca07d0","_type":"link","href":"https://www.jonstokes.com/p/when-software-writes-the-software"}],"_type":"block","style":"normal"},{"_key":"fb444e3c8dc1","children":[{"_type":"span","marks":[],"text":"Artificially intelligent machines can’t ascend to godhood via the long-prophesied runaway spiral of continuous self-improvement until we invent a machine learning model that can code a better version of itself. We’re not there yet, and it’s not clear how far away such a development is, but as of the mid-2021 release of ","_key":"fb444e3c8dc10"},{"_type":"span","marks":["a1d9fc23350a"],"text":"OpenAI’s Codex model","_key":"fb444e3c8dc11"},{"_type":"span","marks":[],"text":", we’re a lot closer than we were just a few years ago.","_key":"fb444e3c8dc12"}],"markDefs":[{"_key":"a1d9fc23350a","_type":"link","href":"https://openai.com/blog/openai-codex/"}],"_type":"block","style":"normal"},{"_key":"a2a2c2043b59","children":[{"_type":"span","marks":[],"text":"Given that self-improving computer programs would likely be the most important human invention since writing, there is no other part of the AI content generation revolution that’s worthy of more study and careful scrutiny than generative models that output code.","_key":"a2a2c2043b590"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"609c2eb74e65","children":[{"_type":"span","marks":[],"text":"And of all the new ML-powered programming offerings in this growing ecosystem, Replit has the tools I’m watching most closely. No other programming platform is in a position to train models on a dataset that includes the following from legions of programmers and millions of projects:","_key":"609c2eb74e650"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"f886e26e70de","children":[{"_type":"span","marks":[],"text":"Real-time keystroke and clickstream data","_key":"f886e26e70de0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"a225c257d9a5","children":[{"_type":"span","marks":[],"text":"Detailed execution and performance data","_key":"a225c257d9a50"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"ae40ce088afa","children":[{"_type":"span","marks":[],"text":"Character-level file changes","_key":"ae40ce088afa0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"720f098e8503","children":[{"_type":"span","marks":[],"text":"If you were going to design a platform for the express purpose of teaching machines to code, it would probably be a cloud-hosted IDE plus execution environment that looks a lot like Replit. So while most of what you’ll read in this article and followups is applicable to all AI code generation tools more generally, I’ll be focusing on Replit’s toolset because right now it’s the richest and most advanced, and has the most potential for advancing the state-of-the-art.","_key":"720f098e85030"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"4d6fa52c8c82","children":[{"_type":"span","marks":[],"text":"In this article series, I’ll walk you through the following topics:","_key":"4d6fa52c8c820"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"302b9dd1c4d4","children":[{"_type":"span","marks":[],"text":"What ML code generation can do right now.","_key":"302b9dd1c4d40"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"a2f1fcfc341a","children":[{"_type":"span","marks":[],"text":"Types of programming work this tech might be used for in the near-to-medium term.","_key":"a2f1fcfc341a0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"6c46bf1137eb","children":[{"_type":"span","marks":[],"text":"The possible (non-singularity) economic, technical, and cultural implications of the widespread adoption of ML in software development.","_key":"6c46bf1137eb0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"db67a12057cf","children":[{"_type":"span","marks":[],"text":"Who these articles are for, in order of focus:","_key":"db67a12057cf0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"3066a004d290","children":[{"_type":"span","marks":[],"text":"New programmers who are just getting started and don’t have a grasp on the history of the field and how it has evolved to the present point.","_key":"3066a004d2900"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"d846e3c81fa2","children":[{"_type":"span","marks":[],"text":"Non-programmers who are curious about what this tech can and can’t do.","_key":"d846e3c81fa20"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"094d2b83b638","children":[{"_type":"span","marks":[],"text":"Experienced programmers who haven’t yet tried any of the new ML-powered coding tools and want to understand what they offer both now and in the future.","_key":"094d2b83b6380"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"80974c3d367d","children":[{"_type":"span","marks":[],"text":"The five eras of programming","_key":"80974c3d367d0"}],"markDefs":[],"_type":"block","style":"h1"},{"_key":"fe750310f659","children":[{"_type":"span","marks":[],"text":"We all know that programming started back in the olden days with punch cards and people flipping levers and whatever other kind of stuff you can go watch a Ken Burns documentary about. While I give honor to all those who labored in sterile labs and offices at the dawn of the computing era and were more fabulously dressed than the Cheeto-fingered nerds who eventually followed them, I’d like to start my own discussion of the history of computing with the era we’re just now emerging out of, which is #3 on the list below:","_key":"fe750310f6590"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"0a66724b129d","children":[{"_type":"span","marks":["strong"],"text":"Programming eras:","_key":"0a66724b129d0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"59bb310cb713","children":[{"_type":"span","marks":[],"text":"Academics and engineers with mainframes and minicomputers","_key":"59bb310cb7130"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"b715ac164c1a","children":[{"_type":"span","marks":[],"text":"Cowboy coders with personal computers","_key":"b715ac164c1a0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"0af4cad28f73","children":[{"_type":"span","marks":[],"text":"Social coding + cloud + specialization","_key":"0af4cad28f730"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"26c0feedbd85","children":[{"_type":"span","marks":[],"text":"ML-powered pair programming","_key":"26c0feedbd850"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"853b9e9300de","children":[{"_type":"span","marks":[],"text":"🤯🚀🤖","_key":"853b9e9300de0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"95e9eae31fe9","children":[{"_type":"span","marks":[],"text":"I came up as a programmer in the PC-powered golden age of the cowboy coder — the hero hacker who authored the first version of some piece of software that changed the world. I eventually made the transition to the second era, which featured the rise of GitHub, the adoption of agile programming practices, and all the stuff that made programming more amenable to “day job” treatment.","_key":"95e9eae31fe90"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"031385b8c25f","children":[{"_type":"span","marks":[],"text":"It was during this time that a kind of ","_key":"031385b8c25f0"},{"_type":"span","marks":["d39605a2070e"],"text":"Weberian routinization of charisma","_key":"031385b8c25f1"},{"_type":"span","marks":[],"text":" took place but in the realm of coding. Success in software projects steadily shifted from being about the unique genius of cowboy coders to being about communication and collaboration among a group of competent professionals of varied backgrounds and skill levels. This shift had three key enabling components:","_key":"031385b8c25f2"}],"markDefs":[{"_key":"d39605a2070e","_type":"link","href":"https://en.wikipedia.org/wiki/Charismatic_authority#:~:text=Routinizing%20charisma,-Charismatic%20authority%20almost&text=It%20tends%20to%20challenge%20this,this%20happens%20is%20called%20routinization."}],"_type":"block","style":"normal"},{"_key":"6d603952e669","children":[{"_type":"span","marks":["strong"],"text":"Social coding","_key":"6d603952e6690"},{"_type":"span","marks":[],"text":" meant that your code needed to be readable, testable, and documented. You’re not just coding for some specialized system, but you’re also coding for other humans who may come to a project after you, or who you may be sharing solutions in venues like StackOverflow.","_key":"6d603952e6691"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"9213a505babb","children":[{"_type":"span","marks":["strong"],"text":"Cloud","_key":"9213a505babb0"},{"_type":"span","marks":[],"text":" meant that a lot of development work was about interacting with APIs. A modern web app became a kind of meeting place where multiple APIs for different SaaS products could be mixed and matched underneath layers of business logic and front-end code.","_key":"9213a505babb1"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"3b9bf2fecd8e","children":[{"_type":"span","marks":["strong"],"text":"Specialization","_key":"3b9bf2fecd8e0"},{"_type":"span","marks":[],"text":" meant the rise of back-end engineers vs. front-end engineers or people who were really good at particular kinds of problems (scaling, dealing with storage, front-end optimization, etc.)","_key":"3b9bf2fecd8e1"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"28b77bcff416","children":[{"_type":"span","marks":[],"text":"I lay out these three elements of the third era of programming, which I’d date from maybe the 2008 launch of GitHub to the 2020 release of OpenAI’s Codex model in private beta because the fourth age of programming will see each of these areas revolutionized.","_key":"28b77bcff4160"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"c0a6db0e3e18","children":[{"_type":"span","marks":[],"text":"Machine learning models have much to offer each of the three parts of the third age, as we’ll see in the following sections.","_key":"c0a6db0e3e180"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"d80887456752","children":[{"_type":"span","marks":[],"text":"Creating a modern web application","_key":"d808874567520"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"4d4d796757cb","children":[{"_type":"span","marks":[],"text":"On a practical level, creating a modern web application involves a whole lot of the following kinds of work:","_key":"4d4d796757cb0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"0371c4dba461","children":[{"_type":"span","marks":["strong"],"text":"Looking up how to talk to an API","_key":"0371c4dba4610"},{"_type":"span","marks":[],"text":", either via a language-specific library or a REST API, and then writing code that makes the correct calls in the correct order.","_key":"0371c4dba4611"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"7ab0d23c6b39","children":[{"_type":"span","marks":["strong"],"text":"Generating boilerplate and scaffolding","_key":"7ab0d23c6b390"},{"_type":"span","marks":[],"text":" to initialize a new app, configure a new library in an existing app, or expand an existing app.","_key":"7ab0d23c6b391"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"e717f5e70a77","children":[{"_type":"span","marks":["strong"],"text":"Understanding code","_key":"e717f5e70a770"},{"_type":"span","marks":[],"text":" that was written by someone else, either some example code on StackOverflow or earlier code from the codebase you’re currently working in.","_key":"e717f5e70a771"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"8e9fa37c5f07","children":[{"_type":"span","marks":[],"text":"The first item on the list can take up quite a bit of the time of a junior or mid-level programmer because you have to know where to look for and how to read the relevant docs. This search and rapid comprehension work is the kind of thing you can get a lot faster at as you do more of it. At some point, you end up having done so many repetitions of this read-comprehend-retype loop that your instincts will tell you what the correct code should look like in most situations – the lookup activity is still necessary, but it’s mostly about confirming what your instincts already told you and about naming things properly.","_key":"8e9fa37c5f070"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"45aef5b5a754","children":[{"_type":"span","marks":[],"text":"Programmers are also constantly looking up and retyping the correct command-line incantations to get the particular permutation of boilerplate or scaffolding required for your app or feature. As with APIs and libraries, you can expect significant speedups with practice.","_key":"45aef5b5a7540"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"16ec95b3f69e","children":[{"_type":"span","_key":"16ec95b3f69e0","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"d0fb6aa82555","children":[{"_type":"span","marks":[],"text":"Finally, reading and understanding someone else’s code is also a matter of gaining fluency with a specific skill that gets better with practice. You’ll do a lot of this when you work on an existing application, but you’ll also do it constantly when writing new code because you’ll need to learn from reading code samples and poking around in test suites for popular libraries and APIs.","_key":"d0fb6aa825550"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"c13fb1d689fd","children":[{"_type":"span","marks":[],"text":"None of these kinds of labor require enormous mental horsepower. Smarter people will improve at these practiceable skills more rapidly than the less smart, but everyone is going to end up at more-or-less the same place, in the end.","_key":"c13fb1d689fd0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"8a9b1a7c1d51","children":[{"_type":"span","marks":[],"text":"We can reframe the three types of work mentioned above in terms of types of mental activity, in order to make it easier to map onto machine learning’s capabilities:","_key":"8a9b1a7c1d510"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"66734d0d1b7c","children":[{"_type":"span","marks":["strong"],"text":"Reading","_key":"66734d0d1b7c0"},{"_type":"span","marks":[],"text":" and rereading code, docs, forums, and StackOverflow, so as to mentally buffer enough of the latest version of all of it to do steps 2 and 3 below.","_key":"66734d0d1b7c1"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"57f1a99b6e3d","children":[{"_type":"span","marks":["strong"],"text":"Pattern-matching","_key":"57f1a99b6e3d0"},{"_type":"span","marks":[],"text":" new programming problems with previously read problem/solution pairs.","_key":"57f1a99b6e3d1"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"eae47e9d452a","children":[{"_type":"span","marks":["strong"],"text":"Retyping","_key":"eae47e9d452a0"},{"_type":"span","marks":[],"text":", in slightly tweaked form, some (pattern-matched) parts of what you’ve read to fit your current programming problem.","_key":"eae47e9d452a1"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"59ed40c0cd25","children":[{"_type":"span","marks":[],"text":"Ultimately, there are many of us — I’ve very much been there as a contract programmer and a startup CTO — for whom much of the work of software development is dominated by those three activities. It’s fortunate, then, that there’s a natural fit in the above activities for generative machine learning models, where the models are ","_key":"59ed40c0cd250"},{"_type":"span","marks":["strong"],"text":"trained","_key":"59ed40c0cd251"},{"_type":"span","marks":[],"text":" on large volumes of existing text, and can then do ","_key":"59ed40c0cd252"},{"_type":"span","marks":["strong"],"text":"pattern-matching","_key":"59ed40c0cd253"},{"_type":"span","marks":[],"text":" (aka “inference”) on novel inputs in order to do guided ","_key":"59ed40c0cd254"},{"_type":"span","marks":["strong"],"text":"generation","_key":"59ed40c0cd255"},{"_type":"span","marks":[],"text":" of some transformed, context-appropriate version of the training data.","_key":"59ed40c0cd256"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"3129b170b719","children":[{"_type":"span","marks":[],"text":"To revisit some concepts from my ","_key":"3129b170b7190"},{"_type":"span","marks":["60f906b1e9b1"],"text":"intro to generative AI","_key":"3129b170b7191"},{"_type":"span","marks":[],"text":", we can now make models where the ","_key":"3129b170b7192"},{"_type":"span","marks":["strong"],"text":"latent space","_key":"3129b170b7193"},{"_type":"span","marks":[],"text":" maps to possible computer programs (instead of it mapping to possible images, strings of natural-language text, sounds, etc.). So by searching latent space via a prompt or some other input, we can uncover interesting and useful blocks of code that make computers do things we want them to do.","_key":"3129b170b7194"}],"markDefs":[{"_key":"60f906b1e9b1","_type":"link","href":"https://www.jonstokes.com/p/ai-content-generation-part-1-machine"}],"_type":"block","style":"normal"},{"_key":"65fa8e05278c","children":[{"_type":"span","_key":"65fa8e05278c0","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"71713af84cc7","children":[{"_type":"span","marks":[],"text":"For another way into this concept, take a statement that was popular in the early days of open-source software, and is currently making a comeback in web3: “code is speech.” To the extent that code is speech, then any model that outputs useful, meaningful, structured chunks of language that humans can interpret can also be made to output useful, meaningful, structured chunks of language that machines can interpret as commands.","_key":"71713af84cc70"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"6dfbac6ad735","children":[{"_type":"span","marks":[],"text":"This sounds like fantasy, but it’s actually being done right now. The results are real, and they’re spectacular.","_key":"6dfbac6ad7350"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"9568a52164b9","children":[{"_type":"span","marks":[],"text":"Nice read on reverse engineering of GitHub Copilot 🪄. Copilot has dramatically accelerated my coding, it's hard to imagine going back to \"manual coding\". Still learning to use it but it already writes ~80% of my code, ~80% accuracy. I don't even really code, I prompt. & edit. ","_key":"9568a52164b90"},{"_type":"span","marks":["e4dbb8228679"],"text":"https://t.co/kvQTOex9Qj","_key":"9568a52164b91"},{"_type":"span","marks":[],"text":"\n\n— Andrej Karpathy (@karpathy) ","_key":"9568a52164b92"},{"_type":"span","marks":["6d50abb55e2c"],"text":"December 30, 2022","_key":"9568a52164b93"}],"markDefs":[{"_key":"e4dbb8228679","_type":"link","href":"https://t.co/kvQTOex9Qj"},{"_key":"6d50abb55e2c","_type":"link","href":"https://twitter.com/karpathy/status/1608895189078380544?ref_src=twsrc%5Etfw"}],"_type":"block","style":"blockquote"},{"_key":"9d713974b2fd","children":[{"_type":"span","marks":[],"text":"Coding with Replit and the current state-of-the-art","_key":"9d713974b2fd0"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"04b7bc1c4535","children":[{"_type":"span","marks":[],"text":"The cloud-hosted programming platform Replit has an excellent, advanced set of ML-powered tools that can substantially reduce the time programmers spend reading, pattern-matching, and re-typing.","_key":"04b7bc1c45350"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"38b62f5415b5","children":[{"_type":"span","marks":[],"text":"There are four main tools that are publicly available right now as part of Replit’s Ghostwriter suite of ML-powered programming tools: ","_key":"38b62f5415b50"},{"_type":"span","marks":["strong"],"text":"generate","_key":"38b62f5415b51"},{"_type":"span","marks":[],"text":", ","_key":"38b62f5415b52"},{"_type":"span","marks":["strong"],"text":"explain","_key":"38b62f5415b53"},{"_type":"span","marks":[],"text":", ","_key":"38b62f5415b54"},{"_type":"span","marks":["strong"],"text":"transform","_key":"38b62f5415b55"},{"_type":"span","marks":[],"text":", and ","_key":"38b62f5415b56"},{"_type":"span","marks":["strong"],"text":"autocomplete","_key":"38b62f5415b57"},{"_type":"span","marks":[],"text":" code.","_key":"38b62f5415b58"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"797460567f04","children":[{"_type":"span","marks":[],"text":"If you've used the popular Stable Diffusion AI image generator or have read my ","_key":"797460567f040"},{"_type":"span","marks":["75f8a620a9d6"],"text":"in-depth introduction","_key":"797460567f041"},{"_type":"span","marks":[],"text":" to it, each of Replit's ML-assisted programming tools has a direct analog to what you can do with that image generator:","_key":"797460567f042"}],"markDefs":[{"_key":"75f8a620a9d6","_type":"link","href":"https://www.jonstokes.com/p/getting-started-with-stable-diffusion"}],"_type":"block","style":"normal"},{"_key":"dd21234e5186","children":[{"_type":"span","marks":["strong"],"text":"Generate","_key":"dd21234e51860"},{"_type":"span","marks":[],"text":" is the code analog of the standard ","_key":"dd21234e51861"},{"_type":"span","marks":["code"],"text":"text2image","_key":"dd21234e51862"},{"_type":"span","marks":[],"text":" operation we're all familiar with, where a text prompt gives you a file from a location in latent space.","_key":"dd21234e51863"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"d96bd4bc4146","children":[{"_type":"span","marks":["strong"],"text":"Explain","_key":"d96bd4bc41460"},{"_type":"span","marks":[],"text":" works a little bit like Stable Diffusion's image-to-text capability, where you can feed it a generated image and a seed and get back the corresponding text prompt. This feature isn't widely known since it's not supported in any of the GUI tools, but the model can do it. More generally, you can use many text-to-image models in reverse to generate a textual description of the contents of the image.","_key":"d96bd4bc41461"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"2b0b3fc4f8d9","children":[{"_type":"span","marks":["strong"],"text":"Transform","_key":"2b0b3fc4f8d90"},{"_type":"span","marks":[],"text":" is the code equivalent of Stable Diffusion's ","_key":"2b0b3fc4f8d91"},{"_type":"span","marks":["code"],"text":"img2img","_key":"2b0b3fc4f8d92"},{"_type":"span","marks":[],"text":" feature, where you're transforming one input image into another with guidance from a text prompt.","_key":"2b0b3fc4f8d93"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"20f43c176a3a","children":[{"_type":"span","marks":["strong"],"text":"Autocomplete","_key":"20f43c176a3a0"},{"_type":"span","marks":[],"text":" is also like ","_key":"20f43c176a3a1"},{"_type":"span","marks":["code"],"text":"img2img","_key":"20f43c176a3a2"},{"_type":"span","marks":[],"text":" but without the explict prompt guidance.","_key":"20f43c176a3a3"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"8e29689c3336","children":[{"_type":"span","marks":[],"text":"Let’s look at each of these in more detail.","_key":"8e29689c33360"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"24a49843a990","children":[{"_type":"span","marks":[],"text":"Generate code","_key":"24a49843a9900"}],"markDefs":[],"_type":"block","style":"h3"},{"_key":"784e91e2f969","children":[{"_type":"span","marks":[],"text":"As I said above, Replit's “generate code” tool is very much like what I described in this ","_key":"784e91e2f9690"},{"_type":"span","marks":["d3a0713204d7"],"text":"intro to Stable Diffusion","_key":"784e91e2f9691"},{"_type":"span","marks":[],"text":", but instead of turning a text prompt into an image, it turns a text prompt into a program in whatever language you’re using in the file you’re editing.","_key":"784e91e2f9692"}],"markDefs":[{"_key":"d3a0713204d7","_type":"link","href":"https://www.jonstokes.com/p/getting-started-with-stable-diffusion"}],"_type":"block","style":"normal"},{"_key":"17a3455ec463","children":[{"_type":"span","_key":"17a3455ec4630","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"4f6628161eb2","children":[{"_type":"span","marks":[],"text":"The main thing this feature does for coders is it lets them tap into the model’s memory (latent space) for code boilerplate and scaffolding, instead of tapping into their own memory.","_key":"4f6628161eb20"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"a60cdc8bb2ae","children":[{"_type":"span","marks":[],"text":"Instead of going out and reading all the docs for, say, writing a Discord bot in JavaScript, and then buffering that information in my own brain (or on my computer’s clipboard) so that I can tweak it to fit my needs, I just pull the starter code from the model’s memory. Once I get the code into my editor, I can do the last bits of tweaking and transforming it, myself.","_key":"a60cdc8bb2ae0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"57f993fc2dfe","children":[{"_type":"span","marks":[],"text":"What “Generate Code” does, then, is to turn this:","_key":"57f993fc2dfe0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"6b19eee94c9f","children":[{"_type":"span","_key":"6b19eee94c9f0","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"8d45bd4991c9","children":[{"_type":"span","marks":[],"text":"Into this:","_key":"8d45bd4991c90"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"aeb502a8ec57","children":[{"_type":"span","_key":"aeb502a8ec570","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"8b676fb1474e","children":[{"_type":"span","marks":[],"text":"As I described in my ","_key":"8b676fb1474e0"},{"_type":"span","marks":["077ca75b428d"],"text":"intro to AI content generation","_key":"8b676fb1474e1"},{"_type":"span","marks":[],"text":", an input prompt for an ML model is essentially a search query, so I’m still turning queries into code just like my non-AI-assisted programming peers — I’m just doing it faster and more directly from right within the editor.","_key":"8b676fb1474e2"}],"markDefs":[{"_key":"077ca75b428d","_type":"link","href":"https://www.jonstokes.com/p/ai-content-generation-part-1-machine"}],"_type":"block","style":"normal"},{"_key":"0ed1f85812a5","children":[{"_type":"span","marks":[],"text":"Explain code","_key":"0ed1f85812a50"}],"markDefs":[],"_type":"block","style":"h3"},{"_key":"16c7c7c7de21","children":[{"_type":"span","marks":[],"text":"Replit’s code explanation feature gives you a short text description of what a highlighted block of code does.","_key":"16c7c7c7de210"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"cfb418698e4d","children":[{"_type":"span","_key":"cfb418698e4d0","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"b4049d27981c","children":[{"_type":"span","marks":[],"text":"In its present state, this tool strikes me as most useful for programmers who are new to a language and trying to grasp the basic mechanics of what an undocumented function is doing.","_key":"b4049d27981c0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"a57c30bbc50d","children":[{"_type":"span","marks":[],"text":"However, what I usually want to know when looking at a piece of code is not “what’s happening?” but “why is this happening?” And the answer to that “why” question always involves some critical context that’s present in some other file of the application.","_key":"a57c30bbc50d0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"fedba6805e03","children":[{"_type":"span","marks":[],"text":"In other words, instead of an English-language walkthrough of what a block of code does when it executes, I typically want an explanation that sounds more like, “This is an event that’s loaded on the page is loaded and fires when the window scrolls down past the target div, so that the next page of items can be retrieved from the database and inserted into the page. The function retrieves the current page from the DOM, sends a query to the server using the current page and current query string, and then calls a function to render the new items with the results from the query.”","_key":"fedba6805e030"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"0b42e00e9dbb","children":[{"_type":"span","marks":[],"text":"This kind of higher-level description, where it’s explaining both the “what” and the “why” of a function within the specific context of the application, seems very likely to be within the reach of a tool like this, but it’s going to take some doing. Right now, there’s just no way to get the amount of context necessary for such an explanation into a pre-trained model — input token windows on current models aren’t nearly large enough to fit a meaningful portion of a real application’s code base.","_key":"0b42e00e9dbb0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"07d17f8d37d0","children":[{"_type":"span","marks":[],"text":"To make the code explanations truly a substitute for pairing with a human programmer who deeply understands the code you’re looking at, my guess is we’ll need models with token windows that are at least in the hundreds of thousands, if not the millions.","_key":"07d17f8d37d00"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"5ae8ba830a8c","children":[{"_type":"span","marks":[],"text":"Transform code","_key":"5ae8ba830a8c0"}],"markDefs":[],"_type":"block","style":"h3"},{"_key":"c024a899bd8c","children":[{"_type":"span","marks":[],"text":"This tool allows you to tweak existing blocks of code by renaming variables, wrapping HTML in tags, wrapping JavaScript functions in a promise, converting older JavaScript dialects to something more modern, or other types of tweaking and cleanup.","_key":"c024a899bd8c0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"011f86f7ab67","children":[{"_type":"span","_key":"011f86f7ab670","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"f15f4b0b5fdc","children":[{"_type":"span","marks":[],"text":"You can even use this tool to translate code from one language to another, which for some of us is even more useful than having it explained in English. For instance, I’m an advanced rubyist but a python newb, so this language translation ability is helpful for me when I’m messing with ML-related Jupyter notebooks on Google Colab.","_key":"f15f4b0b5fdc0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"91eb338890db","children":[{"_type":"span","marks":[],"text":"Autocomplete","_key":"91eb338890db0"}],"markDefs":[],"_type":"block","style":"h3"},{"_key":"e5f4da9f9e93","children":[{"_type":"span","marks":[],"text":"Replit’s autocomplete tool uses the code and comments you’ve already written to infer what code should go next, and then suggests that code for you.","_key":"e5f4da9f9e930"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"0b814c645c36","children":[{"_type":"span","_key":"0b814c645c360","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"b35873fc9ec2","children":[{"_type":"span","marks":[],"text":"The relevant Stable Diffusion analogy here is image2image, where the model is taking the text that’s already in a file, and as you type it’s doing a live search of latent space for code that’s adjacent to what you’ve typed and what you’re typing.","_key":"b35873fc9ec20"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"5b17c9067491","children":[{"_type":"span","marks":[],"text":"Right now, there are a few limitations to this tool that are related to the fact that its suggestions consist of the output of a search of latent space done via a limited input token window:","_key":"5b17c90674910"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"f57761e9c69c","children":[{"_type":"span","marks":[],"text":"The tool doesn’t automatically infer the correct variable names, so when you accept the autocompletion you’ll have to change those, yourself.","_key":"f57761e9c69c0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"72954c074be1","children":[{"_type":"span","marks":[],"text":"Current code suggestion tools, which are based on documentation, are already pretty good, so the performance delta between those and ML-powered autocomplete isn’t always as noticeable right now as it will be in the future.","_key":"72954c074be10"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"efde719cb4ad","children":[{"_type":"span","marks":[],"text":"Again, a much wider input token window will help with both of the above,","_key":"efde719cb4ad0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"50c5f19867db","children":[{"_type":"span","marks":[],"text":"Conclusions","_key":"50c5f19867db0"}],"markDefs":[],"_type":"block","style":"h1"},{"_key":"ab2a16b47e9c","children":[{"_type":"span","marks":[],"text":"The current generation of generative coding models is searching latent space for the programming equivalent of paragraphs of text or pictures — there’s a kind of boundedness here, where the models discover discrete code objects that fits specific contexts.","_key":"ab2a16b47e9c0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"881e4f971bab","children":[{"_type":"span","marks":[],"text":"Contrast this to what we eventually want them to do, which is to reason their way from a problem to a solution by conceiving of and then implementing in code a sequence of steps that follow one from the other.","_key":"881e4f971bab0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"276f4e06591b","children":[{"_type":"span","marks":[],"text":"In other words, currently, it’s up to you as a developer to game out the steps involved in solving a problem — when it comes to implementing each step, you can search latent space (instead of searching Google) to find the right block of code. But latent space isn’t (yet) going to give you the steps, themselves. That’s because causality is still a hard problem in ML and it’s still difficult to get models that can reason capably about cause/effect relationships in order to solve completely novel problems.","_key":"276f4e06591b0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"52325f9eb88e","children":[{"_type":"span","marks":[],"text":"That said, there have been some successful attempts to get LLMs to generate sequences of steps or ideas based on past training inputs, so there’s still plenty of coding magic to be uncovered within the existing LLM paradigm that powers the current generation of tools.","_key":"52325f9eb88e0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"95d0cb1ce0ca","children":[{"_type":"span","marks":[],"text":"In the next article, we’ll take a look at the lifecycle of an application with a view to imagining the kinds of things ML can do for programmers in the near- to medium-term.","_key":"95d0cb1ce0ca0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"7df50d9144a3","children":[{"_type":"span","_key":"7df50d9144a30","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"}],"publishedAt":"2023-01-04T00:00:00.000Z"}