{"_id":"post-49c70ca4-bef4-43fd-9387-5b6ebd09d4cc","_type":"post","title":"Distributed Websocket Rate Limiting","slug":{"_type":"slug","current":"websocket-rate-limiting"},"body":[{"_key":"e23f49946b8a","children":[{"_type":"span","marks":["dd0a315e523f"],"text":"Rate limiting","_key":"e23f49946b8a0"},{"_type":"span","marks":[],"text":" is standard practice for services offering an API. It's used for both protecting against bad actors, for example, attempting ","_key":"e23f49946b8a1"},{"_type":"span","marks":["6174e1ebe596"],"text":"DOS","_key":"e23f49946b8a2"},{"_type":"span","marks":[],"text":" attacks and to simply enforce limits on the service. There are many resources on the web on how to implement a rate limiter in your favorite language/stack. However, I couldn't find anything on how to rate limit Websocket connections (they differ in that they are persistent connections).[](preview end)","_key":"e23f49946b8a3"}],"markDefs":[{"_key":"dd0a315e523f","_type":"link","href":"https://en.wikipedia.org/wiki/Rate_limiting"},{"_key":"6174e1ebe596","_type":"link","href":"https://en.wikipedia.org/wiki/Denial-of-service_attack"}],"_type":"block","style":"normal"},{"_key":"cb883d104865","children":[{"_type":"span","marks":[],"text":"If you're implementing an HTTP API rate limiter and your service endpoint is a single server then it's pretty simple -- you keep an in-memory variable that you increment. Things get trickier, however, when you're serving requests from multiple servers. That's when you start needing a central shared \"state\". For this, most developers use ","_key":"cb883d1048650"},{"_type":"span","marks":["b9581b923685"],"text":"Redis","_key":"cb883d1048651"},{"_type":"span","marks":[],"text":". In fact, the rate limiting use case is so prevalent in Redis that it gets a mention on the docs for the ","_key":"cb883d1048652"},{"_type":"span","marks":["bcc924a8ce6b"],"text":"INCR","_key":"cb883d1048653"},{"_type":"span","marks":[],"text":" function:","_key":"cb883d1048654"}],"markDefs":[{"_key":"b9581b923685","_type":"link","href":"http://redis.io"},{"_key":"bcc924a8ce6b","_type":"link","href":"http://redis.io/commands/INCR"}],"_type":"block","style":"normal"},{"_type":"code","language":"","filename":"","code":"FUNCTION LIMIT_API_CALL(ip)\nts = CURRENT_UNIX_TIME()\nkeyname = ip+\":\"+ts\ncurrent = GET(keyname)\nIF current != NULL AND current > 10 THEN\n    ERROR \"too many requests per second\"\nELSE\n    MULTI\n        INCR(keyname,1)\n        EXPIRE(keyname,10)\n    EXEC\n    PERFORM_API_CALL()\nEND\n","_key":"12bb74639157"},{"_key":"3a229f367c7b","children":[{"_type":"span","marks":[],"text":"The requirement here is to limit calls to 10 calls per second per IP address. So a key is constructed by concatenating the user's IP address with the current timestamp. This is then incremented with every call and checked to make sure they haven't exceeded the limit. Simple enough (you can also implement this using your favorite language and Redis library).","_key":"3a229f367c7b0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"11b38d96ea22","children":[{"_type":"span","marks":[],"text":"In our case, our ","_key":"11b38d96ea220"},{"_type":"span","marks":["1e30a241ed7b"],"text":"code execution API","_key":"11b38d96ea221"},{"_type":"span","marks":[],"text":" gives our customers and users an HTTP and a Websocket interface. The reason you'd need a persistent connection is to build a ","_key":"11b38d96ea222"},{"_type":"span","marks":["81f50baa276a"],"text":"stateful interpreter/REPL","_key":"11b38d96ea223"},{"_type":"span","marks":[],"text":". But persistent connections costs us system resources because we need to start a container and an interpreter/compiler process that waits for the next command to execute. For this reason we have to enforce a limit on concurrent open connections. The challenge with this is implementing it for a distributed service (we serve our users from different servers with no centralized server managing state). As we've seen above, Redis is the go-to technology to solve this problem. However, our use case differs in that we don't limit calls for a certain time interval, instead our limit is one the total number of open connections at any given time.","_key":"11b38d96ea224"}],"markDefs":[{"_key":"1e30a241ed7b","_type":"link","href":"/site/api"},{"_key":"81f50baa276a","_type":"link","href":"/site/blog/swift"}],"_type":"block","style":"normal"},{"_key":"a9bbfb70468b","children":[{"_type":"span","marks":[],"text":"The first solution that came to mind:","_key":"a9bbfb70468b0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"34e7d641bad8","children":[{"_type":"span","marks":[],"text":"Have every server store and update in Redis the current number of connections ","_key":"34e7d641bad80"},{"_type":"span","marks":["em"],"text":"per user","_key":"34e7d641bad81"},{"_type":"span","marks":[],"text":" they're handling","_key":"34e7d641bad82"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"7f2845de67fc","children":[{"_type":"span","marks":[],"text":"Every time a request comes in, we aggregate the number of connections for a given user that all servers are handling and check it against the limits imposed by our service","_key":"7f2845de67fc0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"30972be479a2","children":[{"_type":"span","marks":[],"text":"More concretely, here is how this can be implemented:","_key":"30972be479a20"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"6ef56560f8bc","children":[{"_type":"span","marks":[],"text":"Servers are assigned unique IDs (this could be their IP addresses or what have you)","_key":"6ef56560f8bc0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"fce209ea387d","children":[{"_type":"span","marks":[],"text":"Servers maintain their connection count in a key made up of their unique id and the user id: ","_key":"fce209ea387d0"},{"_type":"span","marks":["code"],"text":"customer-limit-{userId}:{serverUid}","_key":"fce209ea387d1"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"59204bfc96b2","children":[{"_type":"span","marks":[],"text":"Maintaining a count is done by simply constructing the key and incrementing/decrementing it on every connection/disconnection respectively","_key":"59204bfc96b20"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"2727f0bb6ba0","children":[{"_type":"span","marks":[],"text":"Count aggregation for a given user is done by using the Redis pattern matching feature: ","_key":"2727f0bb6ba00"},{"_type":"span","marks":["code"],"text":"KEYS customer-limit-{userId}:*","_key":"2727f0bb6ba01"},{"_type":"span","marks":[],"text":" and then ","_key":"2727f0bb6ba02"},{"_type":"span","marks":["code"],"text":"MGET","_key":"2727f0bb6ba03"},{"_type":"span","marks":[],"text":" to get all the counts","_key":"2727f0bb6ba04"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"fad1121add92","children":[{"_type":"span","marks":[],"text":"Finally sum the counts and check it against the limits imposed by our service for every incoming request for every user","_key":"fad1121add920"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"80cdaa9c42ff","children":[{"_type":"span","marks":[],"text":"This serves our purpose but it has a fundamental flaw. One of the basics in designing distributed systems is to plan for failure -- but this assumes that our servers never fails. If a server goes down (or if the network fails) then it never gets a chance to decrement it's user count and we have zombie \"concurrent users\" counted on our customers for ever. Oops.","_key":"80cdaa9c42ff0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"f5103e15e7b1","children":[{"_type":"span","marks":[],"text":"To handle this I took a similar approach to Redis -- using the ","_key":"f5103e15e7b10"},{"_type":"span","marks":["code"],"text":"EXPIRE","_key":"f5103e15e7b11"},{"_type":"span","marks":[],"text":" function to set an expiration time on our keys. But since we care about the total count we can't just ignore older keys. We need to constantly refresh them (something similar to the ","_key":"f5103e15e7b12"},{"_type":"span","marks":["fa83c610423c"],"text":"DRAM refresh process","_key":"f5103e15e7b13"},{"_type":"span","marks":[],"text":"):","_key":"f5103e15e7b14"}],"markDefs":[{"_key":"fa83c610423c","_type":"link","href":"https://en.wikipedia.org/wiki/Memory_refresh"}],"_type":"block","style":"normal"},{"_type":"code","language":"go","filename":"","code":"/* starts a goroutine that continuously refreshes keys owned by us */\nfunc refresher(pool Pool) {\n    go func() {\n        for {\n            // Grab a redis connection\n            conn := pool.Get()\n            // Get all keys that is \"owned\" by this server\n            keys, err := redis.Strings(conn.Do(\"KEYS\", \"*:\"+serverUid))\n            if err != nil {\n                debug(\"error refreshing keys\", err)\n            } else {\n                for _, key := range keys {\n                    // Expire in 10 minutes unless refreshed (we do it every 3 minutes)\n                    conn.Do(\"EXPIRE\", key, 10*60)\n                }\n            }\n\n            conn.Close()\n\n            // Sleep for three minutes and refresh again.\n            time.Sleep(time.Minute * 3)\n        }\n    }()\n}\n","_key":"17c7c1bb1cc2"},{"_key":"6216f2e9f111","children":[{"_type":"span","marks":[],"text":"This function starts a goroutine that continuously refreshes all keys owned by the server/process. If a server goes down then its keys will be expired (deleted) in 10 minutes. And the connection count will be correct again!","_key":"6216f2e9f1110"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"d74ed8110d9c","children":[{"_type":"span","marks":[],"text":"This works pretty well in practice but ","_key":"d74ed8110d9c0"},{"_type":"span","marks":["82679705d244"],"text":"let me know","_key":"d74ed8110d9c1"},{"_type":"span","marks":[],"text":" if you see any flaws in it ðŸ˜Š","_key":"d74ed8110d9c2"}],"markDefs":[{"_key":"82679705d244","_type":"link","href":"https://twitter.com/amasad"}],"_type":"block","style":"normal"}],"publishedAt":"2016-06-26T07:00:00.000Z"}