{"_id":"post-c4605a50-0f23-4d03-a33e-101735a98f62","_type":"post","title":"Colorizing Stderr: racing pipes, and libc monkey-patching","slug":{"_type":"slug","current":"stderr"},"body":[{"_key":"16adef5153a6","children":[{"_type":"span","marks":["em"],"text":"Errors are red,","_key":"16adef5153a60"},{"_type":"span","marks":[],"text":"\n","_key":"16adef5153a61"},{"_type":"span","marks":["em"],"text":"Outputs are white,","_key":"16adef5153a62"},{"_type":"span","marks":[],"text":"\n","_key":"16adef5153a63"},{"_type":"span","marks":["em"],"text":"File descriptor injection is bold,","_key":"16adef5153a64"},{"_type":"span","marks":[],"text":"\n","_key":"16adef5153a65"},{"_type":"span","marks":["em"],"text":"Let me tell you about","_key":"16adef5153a66"},{"_type":"span","marks":[],"text":" ","_key":"16adef5153a67"},{"_type":"span","marks":["code"],"text":"LD_PRELOAD","_key":"16adef5153a68"},{"_type":"span","marks":[],"text":".\n","_key":"16adef5153a69"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"0c24125ebf17","children":[{"_type":"span","marks":[],"text":"Red errors are important; they make it easy to discern exceptions from standard output. Surprisingly, colorizing stderr is not as straightforward as it sounds and this is the story of racing pipes, file descriptor hacking, and ","_key":"0c24125ebf170"},{"_type":"span","marks":["code"],"text":"libc","_key":"0c24125ebf171"},{"_type":"span","marks":[],"text":" monkey-patching.","_key":"0c24125ebf172"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"4438a32666f1","children":[{"_type":"span","marks":[],"text":"The way it worked on Repl.it for a long time was when you start up a repl you get a container and inside your container, we drop in a ","_key":"4438a32666f10"},{"_type":"span","marks":["em"],"text":"runner","_key":"4438a32666f11"},{"_type":"span","marks":[],"text":" program that talks our REPL protocol and executes code in the respective language. So say the language the user is running is Python then the runner that’s responding to ","_key":"4438a32666f12"},{"_type":"span","marks":["code"],"text":"eval","_key":"4438a32666f13"},{"_type":"span","marks":[],"text":" messages would be written in Python.","_key":"4438a32666f14"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"e45ee4aab807","children":[{"_type":"span","marks":[],"text":"This made colorizing errors easy: we can wrap stdout/stderr with our JSON adapter and wrap the eval call with try/catch and mux everything through stdout and our own custom protocol.","_key":"e45ee4aab8070"}],"markDefs":[],"_type":"block","style":"normal"},{"_type":"codeBlock","language":"text","codeContent":"\nio = sys.stdout\nsys.stdout = JSONStreamAdapter(“stdout”, io)\nsys.stderr = JSONStreamAdapter(“stderr”, io)\n\ntry:\n    result = eval(code)\n    send(io, “result”, result)\nexcept Exception:\n    send(io, “error”, sys.exc_info())\n","_key":"bc9137294e99"},{"_key":"14617d56e715","children":[{"_type":"span","marks":[],"text":"To better understand it, here is a diagram of how a typical Python program is setup:","_key":"14617d56e7150"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"a7dd237b74fa","children":[{"_type":"span","_key":"a7dd237b74fa0","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"ab13d8394e38","children":[{"_type":"span","marks":[],"text":"Now with our adapter here’s how it would look like (notice how both stdout/stderr are going through FD1, which is typically stdout):","_key":"ab13d8394e380"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"f374eddf65fe","children":[{"_type":"span","_key":"f374eddf65fe0","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"4c15d5709f6c","children":[{"_type":"span","marks":[],"text":"This worked reasonably well: we could tell stdout from stderr at the protocol level but it also introduced a few problems -- specifically:","_key":"4c15d5709f6c0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"ca611e449e53","children":[{"_type":"span","marks":[],"text":"Other things that wrote to stdout messed up the JSON transport stream, such as ","_key":"ca611e449e530"},{"_type":"span","marks":["code"],"text":"os.system()","_key":"ca611e449e531"},{"_type":"span","marks":[],"text":" and libraries for terminal manipulation.","_key":"ca611e449e532"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"5d35f345da04","children":[{"_type":"span","marks":[],"text":"Our injected code would sometime confuse the module loading system and built-in names -- such as ","_key":"5d35f345da040"},{"_type":"span","marks":["code"],"text":"__name__","_key":"5d35f345da041"},{"_type":"span","marks":[],"text":" in Python -- so it didn’t scale beyond single file repls.","_key":"5d35f345da042"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"5493d713e7f1","children":[{"_type":"span","marks":[],"text":"It’s a maintenance overhead: every language we add -- and we want to eventually support all of them -- we have to write and maintain a runner.","_key":"5493d713e7f10"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"bullet"},{"_key":"2018055232da","children":[{"_type":"span","marks":[],"text":"Our next attempt at this was to delegate the running of the code directly to the language interpreter, in interactive mode (i.e. ","_key":"2018055232da0"},{"_type":"span","marks":["code"],"text":"python -i","_key":"2018055232da1"},{"_type":"span","marks":[],"text":"). The launching program would allocate a PTY for it, and apply the JSON wrapping.","_key":"2018055232da2"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"193ce6b4c6c9","children":[{"_type":"span","_key":"193ce6b4c6c90","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"346bd224e447","children":[{"_type":"span","marks":[],"text":"This worked well, but now that both stdout and stderr were going through the PTY before could inspect them, we couldn’t colorize our errors red. To differentiate error from the text, we’d need to wedge something in between the process and the PTY. Meet red.c, a little program that injects itself into FD2 (the file descriptor that typically represents stderr), spawns the target program with the correctly arranged file descriptors, and sits in the middle acting as a proxy and colorizing errors.","_key":"346bd224e4470"}],"markDefs":[],"_type":"block","style":"normal"},{"_type":"codeBlock","language":"text","codeContent":"#define _GNU_SOURCE\n#include <stdlib.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <unistd.h>\n#include <string.h>\n\nint errpipe[2];\n\nint ok(int err) {\n    if ( err != 0 ) perror(\"red\");\n}\n\n\nint main(int argc, char **argv) {\n    char **cmd = argv + 1;\n    char *buf = malloc(PIPE_BUF + 10);\n    memcpy(buf, \"\\033[31m\", 5);\n    pid_t child;\n    int status;\n\n    ok(pipe2(errpipe, 0));\n    if ( child = fork() ) {\n        ok(close(errpipe[1]));\n        while ( 1 ) {\n            ssize_t n = read(errpipe[0], buf+5, PIPE_BUF);\n            memcpy(buf + 5 + n, \"\\033[00m\", 5);\n            if ( n == 0 ) break;\n            write(2, buf, n+10);\n        }\n        waitpid(child, &status, 0);\n        return WEXITSTATUS(status);\n    } else {\n        ok(close(errpipe[0]));\n        ok(close(2));\n        ok(-1 == dup(errpipe[1]));\n        ok(execvp(*cmd, cmd));\n    }\n}\n","_key":"de3c51c2eff6"},{"_key":"c0829b59e93d","children":[{"_type":"span","marks":[],"text":"Here is what the diagram looks like now:","_key":"c0829b59e93d0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"769990b1b064","children":[{"_type":"span","_key":"769990b1b0640","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"0242f8b1d3b1","children":[{"_type":"span","marks":[],"text":"This seemed to work well at first but it had a surprising problem: in some cases, output and errors of order.","_key":"0242f8b1d3b10"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"543f0121c5ae","children":[{"_type":"span","marks":[],"text":"The program will deliver data to FD1 and the pipe, but there is a race for red.c to read the data out of the pipe and get it to the PTY before the program writes more data FD1. There’s another failure mode where data gets backed-up at the pipe and it all comes out at the same time. Ultimately, we were at the whims of the kernel scheduler making it all indeterministic.","_key":"543f0121c5ae0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"7abe81f79cb9","children":[{"_type":"span","marks":[],"text":"While for the most part, everything was fast enough that it worked out when the race occurred we’d get wonky behavior like the REPL prompt showing up in the middle of an error.","_key":"7abe81f79cb90"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"1c4b9df20bb4","children":[{"_type":"span","marks":[],"text":"In fact, in any situation where the file descriptors referenced by sys.stdout and sys.stderr don’t point to the same underlying character device, there’s no good way to maintain the programs intended ordering. The question becomes: how do we inject ourselves between sys.stderr and the PTY while keeping the file descriptors intact, and without mucking around with the Python environment. Some sort of dark and forbidden magic.","_key":"1c4b9df20bb40"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"697329818fdc","children":[{"_type":"span","marks":[],"text":"Enter ","_key":"697329818fdc0"},{"_type":"span","marks":["caa070258b46","code"],"text":"LD_PRELOAD","_key":"697329818fdc1"},{"_type":"span","marks":[],"text":": a dynamic linker functionality that makes it possible to load a library and bind its symbols (function and variable names etc) before loading any other library. If you code in dynamic languages you probably know about monkey patching, and in effect, ","_key":"697329818fdc2"},{"_type":"span","marks":["code"],"text":"LD_PRELOAD","_key":"697329818fdc3"},{"_type":"span","marks":[],"text":" can be exploited to do that for C.","_key":"697329818fdc4"}],"markDefs":[{"_key":"caa070258b46","_type":"link","href":"http://www.goldsborough.me/c/low-level/kernel/2016/08/29/16-48-53-the_-ld_preload-_trick/"}],"_type":"block","style":"normal"},{"_key":"224afbc34a27","children":[{"_type":"span","marks":[],"text":"Say you want to monkey patch a C program so that it never reads from the outside. You want it to always return the same thing: “never gonna give you up.”","_key":"224afbc34a270"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"f32e11aa761d","children":[{"_type":"span","marks":[],"text":"Here’s our library to be injected:","_key":"f32e11aa761d0"}],"markDefs":[],"_type":"block","style":"normal"},{"_type":"codeBlock","language":"text","codeContent":"// inject.c\n#include <string.h>\n\nsize_t read(int fd, void *data, size_t size) {\n  strcpy(data, \"never gonna give you up\\n\");\n  return 24;\n}\n","_key":"4868ede01173"},{"_key":"39c329574317","children":[{"_type":"span","marks":[],"text":"Now if we compile a simple C program that uses ","_key":"39c3295743170"},{"_type":"span","marks":["code"],"text":"read","_key":"39c3295743171"},{"_type":"span","marks":[],"text":" to read from stdin and then run it with ","_key":"39c3295743172"},{"_type":"span","marks":["code"],"text":"LD_PRELOAD","_key":"39c3295743173"},{"_type":"span","marks":[],"text":" it will never actually try to read anything -- it will simply return the constant string.","_key":"39c3295743174"}],"markDefs":[],"_type":"block","style":"normal"},{"_type":"embed","_id":"a9e421d0-abb9-440f-bb68-60287d6c37af","url":"https://repl.it/@amasad/monkey-patching?lite=true","_key":"acdd91a75907"},{"_key":"8766c06a12a3","children":[{"_type":"span","marks":[],"text":"Now, for monkey patching to actually work you need to access to the original shadowed symbol -- ","_key":"8766c06a12a30"},{"_type":"span","marks":["code"],"text":"read","_key":"8766c06a12a31"},{"_type":"span","marks":[],"text":" in this case. This is done using a technique known as Symbol Fishing. Luckily this has been done for us by the ","_key":"8766c06a12a32"},{"_type":"span","marks":["9a033f90f0ce"],"text":"stderred","_key":"8766c06a12a33"},{"_type":"span","marks":[],"text":" open-source project.","_key":"8766c06a12a34"}],"markDefs":[{"_key":"9a033f90f0ce","_type":"link","href":"https://github.com/sickill/stderred"}],"_type":"block","style":"normal"},{"_key":"a65236ff9d24","children":[{"_type":"span","marks":[],"text":"Stderred uses ","_key":"a65236ff9d240"},{"_type":"span","marks":["code"],"text":"LD_PRELOAD","_key":"a65236ff9d241"},{"_type":"span","marks":[],"text":" to monkey-patch ","_key":"a65236ff9d242"},{"_type":"span","marks":["code"],"text":"write","_key":"a65236ff9d243"},{"_type":"span","marks":[],"text":" and colorize -- by including the terminal ansi codes for the color red -- anything that's being written to FD2 (stderr):","_key":"a65236ff9d244"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"ff029a7a3071","children":[{"_type":"span","_key":"ff029a7a30710","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"0ef4c5d7cc1c","children":[{"_type":"span","marks":[],"text":"With this, we achieved all our goals: red errors, all the data going to the same character device, and all the modification happening in the same process in the right order.","_key":"0ef4c5d7cc1c0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"ceec3d3d5d92","children":[{"_type":"span","marks":[],"text":"Monkey patching always feels dirty, but also supremely valuable. The downside is your program is running around with a modified standard library. But that’s a small sacrifice to get that sweet red in my terminal.","_key":"ceec3d3d5d920"}],"markDefs":[],"_type":"block","style":"normal"}],"publishedAt":"2018-11-02T07:00:00.000Z"}