{"_id":"post-d3d01523-af21-4e99-85d1-8e830a1d06d0","_type":"post","title":"Building Ghostwriter Chat","slug":{"_type":"slug","current":"ghostwriter-building"},"body":[{"_key":"1c9852124e6d","children":[{"_type":"span","marks":[],"text":"At Replit, we strive to give our users the most powerful programming environment, and what better way is there than giving them an AI pair programmer directly in their workspace? Enter Ghostwriter Chat.","_key":"1c9852124e6d0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"7256af432e38","children":[{"_type":"span","marks":[],"text":"Why we built Ghostwriter Chat","_key":"7256af432e380"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"d829b777de05","children":[{"_type":"span","marks":[],"text":"Many IDEs today are not truly integrated; they lack the tools a developer interacts with throughout the course of their work. With Ghostwriter Chat, our goal is to give developers all the power they need without them ever having to leave the IDE. Gone are the days where you had to search Stack Overflow for an obscure error message, or visit the docs of your favorite package for the millionth time because you forgot what that one argument was called. And since Ghostwriter is built right into your repl, it can use things like file context, chat history, and program output to help you write code, answer questions, or even debug an error. No copying and pasting is required.","_key":"d829b777de050"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"9b8c9ff1060d","children":[{"_type":"span","marks":[],"text":"We started working on Ghostwriter Chat during our Hackweek in January. The project took the first place prize, and we quickly found that we couldn’t live without it. We wanted to be the first to market with an LLM-powered chat application that is native to your editor. We decided to ship it, and did so in a month!","_key":"9b8c9ff1060d0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"4162cb2c0393","children":[{"_type":"span","_key":"4162cb2c03930","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"4c20b6324baa","children":[{"_type":"span","marks":[],"text":"Large Language Models","_key":"4c20b6324baa0"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"5ef5d3ffcf85","children":[{"_type":"span","marks":["5c89a2bc6f08"],"text":"Large language models","_key":"5ef5d3ffcf850"},{"_type":"span","marks":[],"text":" (LLMs) are the underlying technology powering Ghostwriter Chat. The recent advancements in the field make these language models very good at answering programming questions. When building LLMs into your application, speed and prompt construction are some of the most important factors.","_key":"5ef5d3ffcf851"}],"markDefs":[{"_key":"5c89a2bc6f08","_type":"link","href":"https://blogs.nvidia.com/blog/2023/01/26/what-are-large-language-models-used-for/"}],"_type":"block","style":"normal"},{"_key":"16b85f6b6cb7","children":[{"_type":"span","marks":[],"text":"Request Latency","_key":"16b85f6b6cb70"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"b6f7c7f52326","children":[{"_type":"span","marks":[],"text":"When you make a request to a LLM, you are running inference. Under the hood your raw text is tokenized into a format the LLM can understand, these tokens are passed into the network, a forward pass is completed, and then you receive tokens as output. This is quite expensive and takes much longer than your typical request which makes a couple DB calls and does some application logic. It is also amplified by the number of tokens you want to generate. Our users are using Ghostwriter Chat to generate entire code blocks, or even whole programs, which amounts to hundreds of tokens generated in a single request.","_key":"b6f7c7f523260"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"20cb8e5ef21f","children":[{"_type":"span","marks":[],"text":"A typical chat request goes through the following steps:","_key":"20cb8e5ef21f0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"51d4f378f2e3","children":[{"_type":"span","marks":[],"text":"We don’t want a user to sit around and wait multiple seconds for hundreds of tokens to be generated, so we opt to stream the tokens as they are generated back to the user. Streaming gives us the ability to have sub 500 milliseconds from the time a request is sent, to when the user starts seeing a response displayed. This allows the user to also see if a response looks like it is helpful or not, stop generation, and ask the question again with more detail.","_key":"51d4f378f2e30"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"93a284e01569","children":[{"_type":"span","marks":[],"text":"Generic Prompt Construction","_key":"93a284e015690"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"ee1eaa933306","children":[{"_type":"span","marks":[],"text":"When working with LLMs, you need to invest a lot of thought into how you construct your prompt. A carefully constructed prompt with sufficient context can yield a very detailed response, but one without a lot of detail will produce a generic response and hallucinations.","_key":"ee1eaa9333060"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"2d6e0d910d7b","children":[{"_type":"span","marks":[],"text":"For Ghostwriter to be able to help you answer your questions, it needs to have knowledge of the ever changing environment of your repl and your chat history. To succeed, we needed a way to take varying information from different sources, choose what to include and exclude, and convert it to any number of prompt formats to support any number of language models and APIs.","_key":"2d6e0d910d7b0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"6c29e6d14f3e","children":[{"_type":"span","_key":"6c29e6d14f3e0","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"e97f5580e5c9","children":[{"_type":"span","marks":[],"text":"Ghostwriter Debugger","_key":"e97f5580e5c90"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"fb03a6e180a3","children":[{"_type":"span","marks":[],"text":"Ghostwriter Debugger is our AI-powered debugger that will proactively alert you on errors, and allow you to debug in just a single click.","_key":"fb03a6e180a30"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"db57615f5740","children":[{"_type":"span","_key":"db57615f57400","text":"","marks":[]}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"f27456c4f8ec","children":[{"_type":"span","marks":[],"text":"For Ghostwriter Debugger to work, we also need to support the many different ways programs display and throw errors. For example, a running web server can throw errors without pausing execution and continue to output logs, but a script is going to immediately stop with the last output being an error message.","_key":"f27456c4f8ec0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"3e05d841566f","children":[{"_type":"span","marks":[],"text":"Getting Around Token Limits","_key":"3e05d841566f0"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"9c0d14fa1415","children":[{"_type":"span","marks":[],"text":"Unfortunately, language models have a token limit on the input and output tokens. This makes it impossible for us to include all of your repl context, additional external context, and your entire chat history. To get around this, we use some heuristics we feel is a good balance to allow chat to have access to what is most important.","_key":"9c0d14fa14150"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"e0071f5fb7fb","children":[{"_type":"span","marks":[],"text":"Limit the chat history and message length","_key":"e0071f5fb7fb0"}],"markDefs":[],"_type":"block","style":"h3"},{"_key":"bfa3957ef817","children":[{"_type":"span","marks":[],"text":"Assuming that the most recent messages are the most important during a conversation, removing old messages is a good way to keep in these context limits. A message to Ghostwriter counts as part of the prompt and the total limit, so we set a cap at ","_key":"bfa3957ef8170"},{"_type":"span","marks":["code"],"text":"500","_key":"bfa3957ef8171"},{"_type":"span","marks":[],"text":" characters to allow more room for other parts of the prompt (chat history, larger responses, file context). If most users want to reference code they have written in a message and we are including file context already, you can get better results by asking Ghostwriter about the code itself instead of copying and pasting in each message.","_key":"bfa3957ef8172"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"3cbd3624f667","children":[{"_type":"span","marks":[],"text":"Choosing the right context","_key":"3cbd3624f6670"}],"markDefs":[],"_type":"block","style":"h3"},{"_key":"22bc1e67210f","children":[{"_type":"span","marks":[],"text":"For example, a small Repl might only have two files with a hundred or so lines of code. In that case, it’s easy to keep the full context of the repl when interacting with Ghostwriter. But what about larger and more complex Repls? It's impossible to include the entire project when prompting a language model, let alone your chat history, stack traces or any other information.","_key":"22bc1e67210f0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"4d3448abcf96","children":[{"_type":"span","marks":[],"text":"Some files are less relevant than others. A python project might have a directory called ","_key":"4d3448abcf960"},{"_type":"span","marks":["code"],"text":".venv/","_key":"4d3448abcf961"},{"_type":"span","marks":[],"text":", some linter files, some ","_key":"4d3448abcf962"},{"_type":"span","marks":["code"],"text":"pytest","_key":"4d3448abcf963"},{"_type":"span","marks":[],"text":" configurations, a ","_key":"4d3448abcf964"},{"_type":"span","marks":["code"],"text":".gitignore","_key":"4d3448abcf965"},{"_type":"span","marks":[],"text":" file, and a bunch of ","_key":"4d3448abcf966"},{"_type":"span","marks":["code"],"text":"yaml","_key":"4d3448abcf967"},{"_type":"span","marks":[],"text":" CI build files. Are these really going to help make Ghostwriter give users better programming advice? Most likely not. The most relevant files would be things like ","_key":"4d3448abcf968"},{"_type":"span","marks":["code"],"text":"main.py","_key":"4d3448abcf969"},{"_type":"span","marks":[],"text":" and other source code.","_key":"4d3448abcf9610"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"16386de99d02","children":[{"_type":"span","marks":[],"text":"This isnt always the case, but if you are programming and you are stuck, it's almost on the immediate task at hand. We can take advantage of this common flow, by assuming that the most important files for Ghostwriter to know about are the files you are currently working on and have recently worked on. Doing so gives Ghostwriter the most context on the task at hand and increases the likelihood that it assists you as would a true pair programmer.","_key":"16386de99d020"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"991533354f23","children":[{"_type":"span","marks":[],"text":"The Future","_key":"991533354f230"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"26e4bf87849d","children":[{"_type":"span","marks":[],"text":"Ghostwriter Chat will continue to improve as AI and LLMs become more capable. Context length will increase and inference will be faster, which means future versions of Ghostwriter, and other LLM-based applications, will only get smarter, faster, and more powerful.","_key":"26e4bf87849d0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"330bdbf6c83b","children":[{"_type":"span","marks":[],"text":"These trends will allow us to unlock more seamless interaction with our IDE, leverage more relevant context, and allow Ghostwriter to do more complex actions. Ghostwriter will continue to evolve, become more agent-like, and start to be driving entire workflows.","_key":"330bdbf6c83b0"}],"markDefs":[],"_type":"block","style":"normal"}],"publishedAt":"2023-03-27T14:45:00.000Z"}