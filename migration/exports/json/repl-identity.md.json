{"_id":"post-77d67395-3d43-4028-a885-227fdc3c49c2","_type":"post","title":"Zero-Click Auth For Your Apps","slug":{"_type":"slug","current":"repl-identity"},"body":[{"_key":"fb2f60da2873","children":[{"_type":"span","marks":[],"text":"Picture this: you've built an arcade game on Replit. Gamers playing your game will head to the repl's cover page and click \"Run\". They love your game, and they send you feature requests and ideas in the comments. Now, you want to keep track of high scores and add other social features to your game. This used to be a show-stopper: there was no way to verify the API requests coming in, so your high-score feature was either easy to spoof, or simply didn't get off the ground.","_key":"fb2f60da28730"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"a60fe94aeee2","children":[{"_type":"span","marks":[],"text":"We're rolling out Repl Identity to solve this.","_key":"a60fe94aeee20"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"d687718a4eeb","children":[{"_type":"span","marks":[],"text":"Cover Page Runs","_key":"d687718a4eeb0"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"fbce9fff0970","children":[{"_type":"span","marks":[],"text":"When you click \"Run\" on a repl's cover page, we create what we call a \"guest fork\" in the background. For all intents and purposes, this is just like you clicked \"Fork\" on the repl - but it's ephemeral and gets cleaned up when you're finished running that repl. These stateless guest forks make the cover page experience work, but a side effect is that they don't have secrets and they don't share certain resources (like the Repl Database).","_key":"fbce9fff09700"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"ecc4c49a7bf4","children":[{"_type":"span","marks":[],"text":"That's good for you: a user running a guest fork can't get a shell and view all of your secrets!","_key":"ecc4c49a7bf40"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"c43acec86e55","children":[{"_type":"span","marks":[],"text":"However, this functionality makes it hard to figure out how to authenticate a cover page run to any of your other repls that ","_key":"c43acec86e550"},{"_type":"span","marks":["em"],"text":"do","_key":"c43acec86e551"},{"_type":"span","marks":[],"text":" have the secrets. An isolated Repl DB means no data sharing. No secrets means no access to APIs or authentication keys. That's made it significantly harder to build multiplayer, social, or just user-oriented experiences in applications running in the cover page, because they are so isolated. That's what Repl Identity is for.","_key":"c43acec86e552"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"00bebbf3697a","children":[{"_type":"span","marks":[],"text":"Repl Identity","_key":"00bebbf3697a0"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"e6b2bf4b3b0a","children":[{"_type":"span","marks":[],"text":"You can now see a new environment variable appear in your repls - ","_key":"e6b2bf4b3b0a0"},{"_type":"span","marks":["code"],"text":"REPL_IDENTITY","_key":"e6b2bf4b3b0a1"},{"_type":"span","marks":[],"text":". This is a PASETO (","_key":"e6b2bf4b3b0a2"},{"_type":"span","marks":["aecf025c0349"],"text":"https://paseto.io/","_key":"e6b2bf4b3b0a3"},{"_type":"span","marks":[],"text":") token, signed by our infrastructure, that includes verifiable information about the repl.","_key":"e6b2bf4b3b0a4"}],"markDefs":[{"_key":"aecf025c0349","_type":"link","href":"https://paseto.io/"}],"_type":"block","style":"normal"},{"_key":"62091bb0063b","children":[{"_type":"span","marks":[],"text":"You can write code that sends the value of ","_key":"62091bb0063b0"},{"_type":"span","marks":["code"],"text":"REPL_IDENTITY","_key":"62091bb0063b1"},{"_type":"span","marks":[],"text":" to another repl that you run. The other repl can use public keys injected into each repl to verify the token is valid, then you can extract data from the token like Repl ID and username.","_key":"62091bb0063b2"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"2ce051aea7cd","children":[{"_type":"span","marks":[],"text":"What does that mean for your apps? A user clicking \"Run\" on your cover page can be verifiably identified in your server, without clicking a single button or typing a password. That makes high score tables, social features (like chat), or even multiplayer games possible without implementing any other authentication system. The server can now trust that it knows who the user is on the other side, so it can store game state in Repl DB, access APIs using secrets, and send back responses to the client.","_key":"2ce051aea7cd0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"ceaee67d9c4d","children":[{"_type":"span","marks":[],"text":"Once you're verifying tokens, you can just focus on building your app instead of figuring out how to securely authenticate your users.","_key":"ceaee67d9c4d0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"07c695d74481","children":[{"_type":"span","marks":[],"text":"What about Repl Auth?","_key":"07c695d744810"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"94de4e009fb2","children":[{"_type":"span","marks":[],"text":"Repl Auth is designed for your users who are accessing your website from a web browser, using cookie(s) to retain the authentication between sessions. So Repl Auth handles web authentication for you. However, making Repl Auth work with an application that runs with VNC or in the terminal is not trivial. You can and should keep using Repl Auth for web applications you build! But if you find yourself unable to use Repl Auth for your project for some reason, chances are good that Repl Identity solves that problem.","_key":"94de4e009fb20"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"fa5f3992bf80","children":[{"_type":"span","marks":[],"text":"How do I Use It?","_key":"fa5f3992bf800"}],"markDefs":[],"_type":"block","style":"h2"},{"_key":"9fe3a96a065b","children":[{"_type":"span","marks":[],"text":"Here's a ","_key":"9fe3a96a065b0"},{"_type":"span","marks":["c00b2c369eb5"],"text":"demo","_key":"9fe3a96a065b1"},{"_type":"span","marks":[],"text":":","_key":"9fe3a96a065b2"}],"markDefs":[{"_key":"c00b2c369eb5","_type":"link","href":"https://replit.com/@mattiselin/repl-identity#main.go"}],"_type":"block","style":"normal"},{"_type":"embed","_id":"a601af94-b79f-4ddb-adca-3123eadd7aa5","url":"https://replit.com/@mattiselin/repl-identity?embed=true#main.go","_key":"b2b9ec941a05"},{"_key":"42bcd3bc73dc","children":[{"_type":"span","marks":[],"text":"This demo implements both the client and server side of repl identity in the same repl, by verifying its own token and printing the user/repl data enclosed within. When you click \"Run\" (when logged in to Replit), you should see your username.","_key":"42bcd3bc73dc0"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"f4aecc1ab125","children":[{"_type":"span","marks":[],"text":"If you're writing in Go, we've put together a ","_key":"f4aecc1ab1250"},{"_type":"span","marks":["6ba9b1913826"],"text":"Go package","_key":"f4aecc1ab1251"},{"_type":"span","marks":[],"text":" for this already (","_key":"f4aecc1ab1252"},{"_type":"span","marks":["4cc151c6e010"],"text":"docs here","_key":"f4aecc1ab1253"},{"_type":"span","marks":[],"text":"). More packages for other languages are on the way!","_key":"f4aecc1ab1254"}],"markDefs":[{"_key":"6ba9b1913826","_type":"link","href":"https://github.com/replit/go-replidentity"},{"_key":"4cc151c6e010","_type":"link","href":"https://pkg.go.dev/github.com/replit/go-replidentity"}],"_type":"block","style":"normal"},{"_key":"41b91dcdd2b0","children":[{"_type":"span","marks":[],"text":"Using another language, or want to know how it works behind the scenes? Read on for all the low-level technical details!","_key":"41b91dcdd2b00"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"f8d1c8f8447a","children":[{"_type":"span","marks":[],"text":"To implement in your own repls, you'll need a PASETO implementation (there's a handful of them listed on ","_key":"f8d1c8f8447a0"},{"_type":"span","marks":["1d853b516b65"],"text":"https://paseto.io/","_key":"f8d1c8f8447a1"},{"_type":"span","marks":[],"text":") and some way of parsing Protocol Buffers (protobufs, ","_key":"f8d1c8f8447a2"},{"_type":"span","marks":["6b9c5393e69e"],"text":"https://developers.google.com/protocol-buffers","_key":"f8d1c8f8447a3"},{"_type":"span","marks":[],"text":").","_key":"f8d1c8f8447a4"}],"markDefs":[{"_key":"1d853b516b65","_type":"link","href":"https://paseto.io/"},{"_key":"6b9c5393e69e","_type":"link","href":"https://developers.google.com/protocol-buffers"}],"_type":"block","style":"normal"},{"_key":"39024b5acb04","children":[{"_type":"span","marks":[],"text":"The format of these tokens follows a chain of trust - it has a root, intermediate, and leaf. The leaf is what is stored in the ","_key":"39024b5acb040"},{"_type":"span","marks":["code"],"text":"REPL_IDENTITY","_key":"39024b5acb041"},{"_type":"span","marks":[],"text":" environment variable. The footer of the leaf references the intermediate, and the footer of the intermediate references the root.","_key":"39024b5acb042"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"8d4545cdf526","children":[{"_type":"span","marks":[],"text":"The root is a \"key ID\" rather than a full PASETO token. This key ID maps into the ","_key":"8d4545cdf5260"},{"_type":"span","marks":["code"],"text":"REPL_PUBKEYS","_key":"8d4545cdf5261"},{"_type":"span","marks":[],"text":" environment variable - if you extract that, base64-decode it, and use it as an ED25519 public key, you'll be able to verify the signature.","_key":"8d4545cdf5262"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"67e277cfcb70","children":[{"_type":"span","marks":[],"text":"If you're unfamiliar with the format of a PASETO token, a PASETO token is encoded as ","_key":"67e277cfcb700"},{"_type":"span","marks":["code"],"text":"version.type.payload.footer","_key":"67e277cfcb701"},{"_type":"span","marks":[],"text":". We're using ","_key":"67e277cfcb702"},{"_type":"span","marks":["code"],"text":"v2.public","_key":"67e277cfcb703"},{"_type":"span","marks":[],"text":" tokens which mean the payload is unencrypted, but includes a signature. The footer can be used to store metadata, which we use to store metadata about the signing authority (such as the key ID used to sign the token).","_key":"67e277cfcb704"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"c037f76c4803","children":[{"_type":"span","marks":[],"text":"So, you need to:","_key":"c037f76c48030"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"a20a9cb040ef","children":[{"_type":"span","marks":[],"text":"Read the footer of the client-provided token. This is the signing authority - the intermediate - in the form of another PASETO token.","_key":"a20a9cb040ef0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"793b316fc8bb","children":[{"_type":"span","marks":["strong"],"text":"note","_key":"793b316fc8bb0"},{"_type":"span","marks":[],"text":": footers are double-base64 encoded (i.e. base64(base64(footer))) because they are required to be UTF-8 compliant and the protobufs embedded within are not compatible. If you're writing custom code you will need to decode twice.","_key":"793b316fc8bb1"}],"markDefs":[],"_type":"block","style":"normal","level":2,"listItem":"bullet"},{"_key":"42e0f96b682a","children":[{"_type":"span","marks":[],"text":"Read the footer of the intermediate token. This will reference a specific key ID in its footer.","_key":"42e0f96b682a0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"be0031957cd2","children":[{"_type":"span","marks":[],"text":"Read the ","_key":"be0031957cd20"},{"_type":"span","marks":["code"],"text":"REPL_PUBKEYS","_key":"be0031957cd21"},{"_type":"span","marks":[],"text":" environment variable and extract the public key mapped to that key ID.","_key":"be0031957cd22"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"60fdc81a80ad","children":[{"_type":"span","marks":[],"text":"Verify the signature of the intermediate - if it passes verification, the intermediate includes a GovalCert protocol buffer message. This includes a public key that you can extract.","_key":"60fdc81a80ad0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"528968269b40","children":[{"_type":"span","marks":[],"text":"Use the intermediate's extracted public key to verify the signature of the client-provided token.","_key":"528968269b400"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"04b07e67ad55","children":[{"_type":"span","marks":[],"text":"The chain has now been verified, and you can consume the payload in the client token. This is a GovalReplIdentity protocol buffer message.","_key":"04b07e67ad550"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"a50f97f804db","children":[{"_type":"span","marks":[],"text":"You can also now check the \"audience\" claim which can be provided by a client to create a non-forwardable token (usually you can use a repl ID for this)","_key":"a50f97f804db0"}],"markDefs":[],"_type":"block","style":"normal","level":1,"listItem":"number"},{"_key":"180766f559ea","children":[{"_type":"span","marks":[],"text":"Once you've verified the chain and extracted the payload, you can trust the fields. Another user can't spoof the token as long as you only use ","_key":"180766f559ea0"},{"_type":"span","marks":["code"],"text":"REPL_PUBKEYS","_key":"180766f559ea1"},{"_type":"span","marks":[],"text":" public keys to verify the chain (as the root is a private key owned by Replit).","_key":"180766f559ea2"}],"markDefs":[],"_type":"block","style":"normal"},{"_key":"c66cce909d48","children":[{"_type":"span","marks":[],"text":"A quick note on forwarding tokens. The client can use ","_key":"c66cce909d480"},{"_type":"span","marks":["code"],"text":"REPL_IDENTITY_KEY","_key":"c66cce909d481"},{"_type":"span","marks":[],"text":" (a key unique to your ","_key":"c66cce909d482"},{"_type":"span","marks":["em"],"text":"container","_key":"c66cce909d483"},{"_type":"span","marks":[],"text":") to sign the repl identity token with an associated \"audience\". Servers can check that the audience matches what they expect (e.g. their own repl ID) before accepting the token. It's highly recommended that you add a signed audience claim in your clients so servers can't forward your token and pretend to be you. ","_key":"c66cce909d484"},{"_type":"span","marks":["code"],"text":"createIdentityTokenAddressedTo","_key":"c66cce909d485"},{"_type":"span","marks":[],"text":" in ","_key":"c66cce909d486"},{"_type":"span","marks":["9e05287d8e21"],"text":"https://replit.com/@mattiselin/repl-identity?v=1#main.go","_key":"c66cce909d487"},{"_type":"span","marks":[],"text":" implements this additional signing step to make the tokens non-forwardable.","_key":"c66cce909d488"}],"markDefs":[{"_key":"9e05287d8e21","_type":"link","href":"https://replit.com/@mattiselin/repl-identity?v=1#main.go"}],"_type":"block","style":"normal"},{"_key":"c983c283b4fc","children":[{"_type":"span","marks":[],"text":"We're excited to see what you build with Repl Identity! I've already built a project on Replit that uses it - check it out here: ","_key":"c983c283b4fc0"},{"_type":"span","marks":["b2884f75e3ff"],"text":"https://replit.com/@mattiselin/BBS-Client","_key":"c983c283b4fc1"}],"markDefs":[{"_key":"b2884f75e3ff","_type":"link","href":"https://replit.com/@mattiselin/BBS-Client"}],"_type":"block","style":"normal"}],"publishedAt":"2022-08-02T16:00:00.000Z"}