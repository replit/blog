<p>Figuring out how to install third-party libraries can derail people from learning to code or starting a new side project. We built the <a href="https://blog.replit.com/upm">Universal Package Manager</a> (UPM for short) to save people from having to think about package installation at all. Just import the library, press run, and UPM will install it into your repl!</p>
<p>Every time you run a repl or a repl wakes up, UPM checks to see if it needs to download and install any dependencies. This is handy (no matter what&#39;s gone inside your repl, it will always have the dependencies it needs) but slow: UPM needs to download typically tens of megabytes worth of packages, extract them on the local filesystem, and sometimes also pre-compile them for better runtime performance.</p>
<p>Or at least it used to be slow until yesterday when we enabled the Python package cache, so now the most popular Python packages are pre-populated in pip&#39;s cache (<code>/home/runner/.cache/pip</code>), so the download step is going to be mostly gone for the <em>vast</em> majority of Python repls! It also uses pre-built wheels as much as possible to avoid even having to pre-compile code.</p>
<h2>How does it work?</h2>
<p>We had two goals in mind when we started designing this:</p>
<ol>
<li>it should be as transparent as possible, which meant that users would still be able to add packages to the local cache while avoiding copying files around (which would have defeated the purpose of using a cache in the first place), and</li>
<li>each repl&#39;s cache should be independent of each other, to prevent cross-repl cache attacks (pollution, poisoning, etc.).</li>
</ol>
<p>To achieve both goals, we are using the same technique that Docker uses to be able to share files between images: the <a href="https://www.kernel.org/doc/html/latest/filesystems/overlayfs.html">Overlay Filesystem</a>. On each machine that <a href="https://blog.replit.com/killing-containers-at-scale#replit-architecture">runs repls</a>, we have a read-only snapshot of the contents of the cache after installing the most popular packages. The snapshot is read-only bind-mounted into each repl into <code>/mnt/cacache</code>. We then perform an Overlay-mount into the directory where the cache expects it to be (<code>/home/runner/.cache/pip</code>), using <code>/mnt/cacache/pip</code> as the &quot;lower&quot; directory and  <code>/mnt/scratch/cacache_pip/upper</code> (a user-writable directory) as the &quot;upper&quot; directory. This means that the shared files cannot be modified, and each repl has a <a href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a> view of the cache.</p>
<p>In order to keep the cache contents fresh, we gather stats about packages being downloaded from <a href="https://pypi.org/">PyPI</a>, and every week we&#39;ll rebuild the cache with the list of most popular pip packages.</p>
<p>Thanks to this, the average time to install packages has gone down ~40% across all <a href="https://blog.replit.com/alwayson">Always On</a> repls.</p>
<p><img src="https://blog.replit.com/images/python-package-cache/packages-time-to-install.png" alt="Always-on package time-to-install" title="The cardinal sin of data visualization: unmarked axes"></p>
<h3>&quot;cacache&quot;?</h3>
<p>The name is derived from <a href="https://en.wikipedia.org/wiki/Content-addressable_storage"><strong>C</strong>ontent-<strong>A</strong>ddressable storage</a> (plus &quot;cache&quot;). One of the properties that is needed for all this to work is that when a package is installed into the system, it is placed in a stable location in the filesystem that depends on the <em>contents</em> of the package (typically the hash of the contents). Every time a package is going to be installed, the package installer (<code>pip</code> in the case of Python) asks the package server for the metadata about the package, which includes the hash of the package. This hash is used to find whether the file is already in the cache, and the local copy is used instead of downloading a new one. Furthermore, since the hash of the contents of the package is already available, the contents can be checked for integrity by comparing the hash of the local copy with the expected one!</p>
<p><a href="https://pip.pypa.io/en/stable/">pip</a> (for Python), <a href="https://www.npmjs.com/">npm</a> (for Node.js), and <a href="https://maven.apache.org/">Maven</a> (for Java) all use content-addressable caches.</p>
<h2>What&#39;s next?</h2>
<p>We&#39;re going to give the same treatment to Java (Maven packages) and JavaScript (npm packages) repls in the next couple of weeks to complete the three most popular languages. Plus a mysterious &quot;language&quot; that will be unveiled soon.</p>
<p>Happy (Python) repling!</p>
