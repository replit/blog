<p>Earlier this year, we discovered that we were losing data for some of our users. This manifested as either repls being completely empty after reloading, or some of the changes to files not being present after reloading. Obviously losing data is the worst we can do, so we had to fix this immediately. This blog post narrates the adventure of how we discovered this, how we fixed it, and the lessons we learned during the way.</p>
<h2>The discovery</h2>
<p>Throughout the year, we had had some worries about some theoretical cases in which users could lose data. We have had a few complaints from people that their code wasn&#39;t correctly saved, and since we weren&#39;t sure what caused them, we just tried to fix bugs here and there one at a time in an unstructured fashion.</p>
<p>Around mid-July, we got an alarmingly large number of reports of people about their code not saving correctly in a short amount of time, ironically just after deploying one such fix. This meant two things: our intuition about folks losing data was correct, but the way we were fixing it was not! This led to the immediate discovery that there were months- or years-old bugs that were silently losing <em>or</em> corrupting data, and some of them turned out to be <a href="https://twitter.com/amye/status/1097686448260579328">load-bearing bugs</a> that couldn&#39;t be fixed in isolation (since fixing them triggered <em>other</em> kinds of data loss). This made us start a much larger project to have better guarantees and incrementally fix things without regressions.</p>
<figure>
  <image src="./images/data-loss/simpsons-bugs.gif">
  <figcaption>Homer Simpson doing a dramatic impression of this whole situation</figcaption>
</figure>

<h2>The fix</h2>
<p>First order of business was to restore order to the world. Luckily, since this got noticeably worse <em>just</em> after a deployment, we had the advantage that a <a href="https://outage.party/">revert-first, ask questions later policy</a> worked wonderfully. But now we also had to fix the several months-old corrupt data that we had already persisted, because corrupt data was causing repls to not be able to load at all! We decided to address this in a more structured approach:</p>
<ul>
<li>Log and monitor all the places where we were suspecting that data could be lost. This way we could clearly see whether a change was indeed improving something or not.</li>
<li>When a repl was being loaded <em>and</em> we discovered that the data that was being loaded was corrupt, discard the corrupt part of the data and salvage whatever we could. The rationale was that it&#39;s preferable to have a partially-restored data rather than a permanently inutilizable repl.</li>
<li>Make sure that we could never persist data that was corrupt by carefully analyzing the output of the filesystem snapshotting tool before committing it. This meant that we could have a good guarantee that anything written after a certain point in time was not corrupt.</li>
<li>Write a batch <a href="https://cloud.google.com/dataflow">Dataflow pipeline</a> that could go through all of the older repls efficiently and perform the same salvaging operation that was run live when repls were being loaded.</li>
<li>Finally, remove all the scaffolding introduced earlier to make repls load fast again.</li>
</ul>
<p>In case anybody is curious, the root cause happened to be a bad interaction between how Golang&#39;s <a href="https://pkg.go.dev/os/exec#Cmd"><code>exec.Cmd</code></a> handles stdin/stdout if they can be directly connected to the underlying process, how one of the userland tools that we use to save repls&#39; filesystem snapshots didn&#39;t quite check for <em>some</em> obscure failures in the very last call to the <a href="https://man7.org/linux/man-pages/man2/write.2.html"><code>write(2)</code></a> and/or <a href="https://man7.org/linux/man-pages/man2/splice.2.html"><code>splice(2)</code></a> syscalls that could happen when the system is under heavy load, and the system running short on available disk space. All of these factors together meant that we could sometimes get a silently truncated stdin/stdout from one of those programs, and no error being raised!</p>
<p>By the end of July, we had <a href="https://blog.replit.com/changelog-07-21">all the mitigations</a> in place, <a href="https://www.youtube.com/watch?v=IjmtVKOAHPM">thus solving the problem once and for all</a>!</p>
<h2>Never let a good crisis go to waste</h2>
<p>Once we had stopped the bleeding and we were sure that we were no longer losing users&#39; data, we decided to improve things to avoid regressions in the future. With logging and monitoring in place, plus tests for all the ways in which we knew we had lost data in the past, we felt <em>a lot</em> more comfortable making changes.</p>
<p>All of the things that we had suspicion that were losing data received a large overhaul to make them more understandable. During that refactoring, we discovered that there were two more places that were not only prone to losing data, but also being very slow: handling filesystem snapshots and persisting <a href="https://blog.replit.com/collab#protocol-changes--operational-transformation">Operational Transformation</a> history for each file. During the course of the next month we <em>very slowly</em> rolled out a few changes that would simultaneously make those two operations more reliable <em>and</em> faster! Today, repls load quicker than they did back in July, and they are more responsive as an added bonus, especially in multiplayer!</p>
<h2>Lessons learned</h2>
<ul>
<li>Losing user data is pretty much the worst that we can do for our users, and that needs immediate attention.</li>
<li>It&#39;s fine to live with brokenness for limited periods, as long as we fix things that are legitimate problems that affect people.</li>
<li>Measuring things in general is extremely important. Adding measurement and logging <em>before</em> improving things is critical.</li>
<li>Once we decide to fix something, might as well improve it.</li>
</ul>
