<p>Having <a href="https://blog.replit.com/quality">a solid foundation</a> is critical for us to be able to fulfill our mission of making programming more accessible, more creative, and more fun. We did a great job of making the platform more stable during last year, but every now and then we would still run into unforeseen problems that <a href="https://en.wikipedia.org/wiki/Cascading_failure">cascaded</a> into other parts of the platform, producing a bad experience for everyone. So back in October (just a few weeks after I joined the team) when we had 2 load-related site-wide outages within a week, we knew it was time to do a major overhaul of how our infrastructure handles traffic. And now today, we&#39;re announcing that as a side effect of that infrastructure change, <a href="https://replit.com/site/pricing">Hacker</a> repls now run in newer, more powerful machines, which means that we&#39;ll have more room to grow and experiment with more benefits for Hackers (and you might find that things feel a little bit snappier lately). This is the first of a three-part series of blogposts on how we rebuilt our infrastructure over the course of ~5 months.</p>
<h2>Introducing a new failure domain</h2>
<p>The original goal of this endeavor was simple, in theory: split the Replit infrastructure into multiple <a href="https://en.wikipedia.org/wiki/Failure_domain">failure domains</a>, so that when (not if) the next incident occurs, it only affects a subset of the users instead of all of them. There are multiple strategies to do so, and we chose to move Hackers to their own failure domain. But what does this split entail? Prior to this change, our backend infrastructure was relatively simple: a Google Compute <a href="https://cloud.google.com/compute/docs/instance-groups">Managed Instance Group</a> of VMs that <a href="https://blog.replit.com/killing-containers-at-scale#replit-architecture">run containers</a>, and another one that serves HTTP traffic on <code>.repl.co</code> domains.</p>
<p><img src="https://blog.replit.com/images/welcome-to-the-wonderful-world-of-clusters/clusters-before.png" alt="Simplified Replit.com infrastructure architecture" title="Simplified Replit.com infrastructure architecture"></p>
<p>So in theory if we take the right-hand side of the diagram and make multiple copies of it, treating each one as a completely independent cluster, we solve the problem. <a href="https://i.kym-cdn.com/entries/icons/original/000/001/899/mission_accomplished.jpg">Mission accomplished</a>, right? Not quite: clients now need to know where to make their requests to, since they will now need to hit different hostnames depending on which cluster their repls are (since they are now completely independent after all). Clients that wanted to connect to their repl through the workspace were already required to contact the replit.com web server to get an auth token for the WebSocket connection anyways, so it would make sense for the web server to be the source of truth about the repl-&gt;cluster mapping. But what about <a href="https://blog.replit.com/hosting">hosting</a>? All repls get a <code>.repl.co</code> domain, and users can CNAME them to be able to get to their app. At this point, the problem started looking very DNS-shaped, and that&#39;s kind of what we ended up doing: an external cluster resolution service, that can be used by both the Replit.com web server and individual clients trying to access their apps!</p>
<p><img src="https://blog.replit.com/images/welcome-to-the-wonderful-world-of-clusters/clusters-after.png" alt="Simplified and updated Replit.com infrastructure architecture" title="Simplified and updated Replit.com infrastructure architecture"></p>
<p>Given that everybody needed to make a DNS query to get the address of their <code>.repl.co</code> domains, exposing an external DNS server on the cluster resolution service made sense, which also made it such that there is no additional latency involved in this resolution!</p>
<p>With all the building blocks in place, there was one final thing that needed addressing: <a href="https://en.wikipedia.org/wiki/Eventual_consistency">Eventual consistency</a>. Distributed systems that are resilient, as well as those that have any amount of caching in place, benefit from being able to tolerate slightly stale information gracefully, with the knowledge that eventually the whole system will converge into a stable state. In this case, it is possible for one user to be transferred between clusters: since Hackers are located in a separate cluster, if the users&#39; subscription status changes, they need to be relocated. DNS results can be cached for prolonged periods of time, which means that we need to be able to handle the case where a user tries to access their old cluster for that period of time. For that case, we use another tool from the distributed systems toolbox: <a href="https://en.wikipedia.org/wiki/Tombstone_(data_store)">Tombstones</a>. When a user is moved from one cluster to another, a Tombstone is created in their original cluster, pointing at the destination cluster. Any attempts to contact any of their repls in the original cluster will then be responded by proxying the connection transparently to the new cluster during the TTL of the DNS record. And with that, the solution is now complete!</p>
<p>One of Replit&#39;s internal mantras is to <a href="https://freakonomics.com/podcast/in-praise-of-incrementalism/">ship things incrementally</a>, even though we didn&#39;t transfer Hackers to their new cluster until fairly recently, all the infrastructure was in place beforehand. In order to test things out, during another load-related incident we decided to give this idea a try and move one user that had an extremely popular repl to the new cluster to test whether the goal of this project was achieved. Even though we knew there were rough edges, and the user transfer process was not widely tested before, we took a chance and used it. To our surprise, things worked better than we expected, and the incident was mitigated before it became a lot worse. Over the next weeks, the new cluster became one more way for us to move load around in times of emergency, which was a nice side-effect.</p>
<p>You might also remember that we blogged about our new <a href="https://blog.replit.com/global">global deployments</a>: this was also one intermediate step of this project that we were able to launch early.</p>
<h2>What this means for Hackers</h2>
<p>Now that we are able to provision separate infrastructure for each cluster, the first thing that came to mind was to experiment with provisioning slightly different hardware in each cluster. To start, we are trying out how responsive repls are if they are running on machines that have a bit more headspace in terms of CPU and memory, since our theory is that there will be less contention over scheduling. We have a few more experiments planned to make the Hacker experience better, and we&#39;re going to make an announcement about this very soon.</p>
<h2>What&#39;s next?</h2>
<p>As I mentioned in the beginning of the article, this is part of a series of blogposts. In the next installment, Connor Brewster will go into more detail about our brand new DNS server. To wrap things up, Zach Anderson will describe some of the big deployment changes that we needed to do to achieve all this.</p>
<p>Happy repling!</p>
