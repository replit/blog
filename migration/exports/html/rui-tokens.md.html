<p><img src="https://blog.repl.it/images/rui/tokens/tokens-social.png" alt="Cover image: different rectangles with of different sizes &amp; colors representing different visual tokens"></p>
<p>Part 1 of a series about our evolving design system, RUI (Replit User Interface).</p>
<hr>
<p>Replit is growing fast, as an application and a team. New features are being added, new people are joining the platform, and new designers and engineers are building it all. Unfortunately, this means that different parts of the product start to look and behave differently, because no single designer or engineer can keep all the interface states in their head.</p>
<p>With dozens of people working on Replit, what happens when you want to update your color or text scheme across the whole site? What if you want users to be familiar with how components work anywhere they see them? It doesn&#39;t happen by accident — it requires strong infrastructural basics that you can rely on.</p>
<p>So, we spent a few months this year building a stronger foundation for our design system. This is how our system is structured now: </p>
<p><img src="https://blog.repl.it/images/rui/tokens/RUI.png" alt="RUI heirarchy: Tokens are composed into Utilities are composed into Components are composed into Patterns are composed into Design Guidance"></p>
<p>Each layer is a set of patterns that are used to compose the layer above it.</p>
<p>We started with the most primitive layer: tokens. Tokens are just core visual attributes that we can apply in design tools (Figma) and on in our codebase (CSS). They describe appearance, but don’t describe behaviour. Here are some examples:</p>
<p><img src="https://blog.repl.it/images/rui/tokens/token-examples.png" alt="Examples of tokens: accentPrimaryStronger corresponds to a light blue on Dark theme and dark blue on Light theme; borderRadius8 corresponds to rounded corners of 8px radius; fontSizeSubheadDefault corresponds to a font size of 16px; and shadow2 corresponds to a dim but noticable drop shadow."></p>
<p>Having a clear, predictable, and easy-to-learn set of tokens is important because it helps us create new interfaces quickly, and lets designers and engineers speak a common language.</p>
<p>We have tokens for:</p>
<ul>
<li>Colors </li>
<li>Spacing sizes </li>
<li>Font sizes</li>
<li>Font families</li>
<li>Font weight</li>
<li>Line-height</li>
<li>Drop shadows</li>
<li>Border radius</li>
</ul>
<p>We had a rough token system in the codebase already, which was a great place to start from (compared to setting values manually.)</p>
<p>That being said, there were lots of ways we improved the usability of the system we had:</p>
<h2>Clearer Naming</h2>
<h3>Before:</h3>
<p>Lots of our tokens were named by number. Like the color tokens: <code>foreground-1</code>, <code>foreground-2</code>, <code>foreground-3</code>, etc. What&#39;s the problem with this? Well, when you see <code>foreground-3</code> in the codebase, it&#39;s unclear what that number means. Does 3 refer to… how dark the color is? How saturated it is? Does the scale start high, or low? What do I use most of the time?</p>
<p>We also used arbitrary titling, like <code>font-size-medium</code>. What&#39;s medium? Is that like… medium for text, or medium for headlines? Medium compared to what?</p>
<h3>After:</h3>
<p>For tokens without a clear numeric measure, we named them after their intended use. For example, <code>foreground-default</code> &amp; <code>foreground-dimmer</code> as opposed to <code>foreground-1</code> &amp; <code>foreground-2</code>.</p>
<p>We debated lots of different naming approaches, especially for the color scales. Should the color scale be lowest → highest? Dimmest → brightest? 100 → 900?</p>
<p>The two concepts we wanted to capture were &quot;How much contrast does this color have compared to the background?&quot; and &quot;What elevation does this background color belong at?&quot;</p>
<p>We settled on a &quot;dimmest → strongest&quot; scale for most colors, because it works across themes:</p>
<p><img src="https://blog.repl.it/images/rui/tokens/color-naming.png" alt="Naming structure for colors goes from &quot;dimmest&quot; (the least contrast against the background) to &quot;strongest&quot; (the most contrast against the background)"></p>
<p>And for core colors, we used the same &quot;dimmest&quot; scheme, but use elevation (from root to highest) to distinguish the background colors. The primary motivation for changing background colors is to place elements on a higher or lower elevation layer:</p>
<p><img src="https://blog.repl.it/images/rui/tokens/default-colors.png" alt="The naming structure for core colors includes &quot;highest, higher, default, and root&quot; options for the background colors; &quot;dimmest, dimmer and default&quot; for outline colors; and &quot;dimmest, dimmer, default&quot; for foreground colors"></p>
<p>For tokens with direct measures like <code>px</code>, we named them directly after the measure. For example, <code>font-size-14: 14px</code> instead of <code>font-size-medium: 14px</code>. No guessing!</p>
<h2>Number of tokens</h2>
<p>We also had lots of tokens. So many tokens. Some that weren&#39;t used anywhere in the codebase! It&#39;s good to be prepared, but every additional token means more cognitive load when deciding which one to use.</p>
<p>We started with 83 tokens, and trimmed down to 72 <em>while</em> adding categories of tokens we didn&#39;t have before, such as <code>line-height</code> and <code>border-width</code>. We eliminated tokens that weren&#39;t used or were rarely used, and made sure each token was visually distinct.</p>
<p><img src="https://blog.repl.it/images/rui/tokens/foreground-before-after.png" alt="Before: 7 foreground tokens, After: 3 foreground tokens"></p>
<h2>Strict typing</h2>
<h3>Before:</h3>
<p>We also had another problem — typos! Because all our tokens were implemented through raw CSS variables, you wouldn&#39;t get a lint or compiler error if you mistyped a variable. I personally cleaned up somewhere between 30 and 50 typos.</p>
<p>Some of my favorite typos: </p>
<ul>
<li><code>var(--sapcing-1)</code></li>
<li><code>var(--var-color-control)</code></li>
<li><code>var(--font-size-deskptop-text-medium)</code></li>
<li><code>var(--coloe-foreground-1)</code></li>
<li><code>var(--color-bacjkground-2)</code></li>
</ul>
<h3>After:</h3>
<p>Now, we use <a href="https://emotion.sh/">emotion</a> to provide a CSS API to our components. We export all of our tokens as an object we can access across our files with <code>vars.tokenName</code> (for example, <code>vars.fontSizeDefault</code>), which comes with easy autocomplete and throws errors if you mistype.</p>
<p>We&#39;re probably writing another post that dives deeper into this topic, so stay tuned!</p>
<h2>Try it out!</h2>
<p>Want to try our tokens? See how we use them in production? Fork <a href="https://replit.com/@BarronWebster/RUI-Token-Playground#src/App.tsx">this repl</a> and play around with our token playground!</p>
<h2>Outro</h2>
<p>All good things are done in groups. This work was done primarily by myself, <a href="https://twitter.com/tylerangert">Tyler Angert</a>, <a href="https://twitter.com/alex_frantic">Alex Kotliarskyi</a>, and Ashlynn Levenick.</p>
<p>We&#39;re still working on RUI — design systems are never done! So keep your eye on the blog for more posts about RUI :)</p>
<p>Want to learn more about design systems in general? Check out <a href="https://www.designsystems.com/">designsystems.com</a></p>
